<!doctype html>
<html lang="en">
<meta charset="utf-8">
<title>Towards Homoiconicity for {C.like;} languages</title>
<link rel="stylesheet" href="common.css" />
<style>
  .token, script.visible, .tleaf, .input, .term {
      font-family: "Inconsolata", "Consolas", "Lucida Console", "Monaco", monospace
  }
  .input:before, .input:after, .token:after, .token:before, summary > .tree:before,
  .tleaf:before, .tleaf:after, pre.hoisted:before {
      font-family: "Noto Sans", "Lucida Grande", "Lucida Sans", "Segoe UI", "Verdana", sans-serif;
  }

  .token { border: 1px solid dotted; background: #eee; white-space: nowrap }
  .token.synthetic { font-style: italic }
  .input { display: inline-block; white-space: pre }
  .input:before { content: "Input: \201c" }
  .input:after { content: "\201d" }
  .tokens:before { content: "Tokens: " }
  #tio-table .tokens:before { content: "" }
  dl > dt:after, .token:after { content: "\201d" }
  dl > dt:before, .token:before { content: "\201c" }
  summary > .tree:before { content: "Tree: " }
  .tree { white-space: pre-wrap }
  .expected:before { content: "Wanted: " }
  .testcase.fail {
      border: 1px solid red;
  }
  .testcase {
      margin: .5em;
      border: 1px dotted black;
      padding: .25em;
  }

  script.visible {
      display: block; white-space: pre; border: 1px solid black
  }

  pre.hoisted {
      position: relative;
  }
  pre.hoisted:before {
      content: "Hoisted code";
      display: block;
      position: absolute;
      left: -.8em;
      top: -1.6em;
      font-size: 8px;
      border: 1px solid #444;
      padding: 2px;
      line-height: 1.2em;
      background: #ddf;
      color: #444;
      font-weight: bolder;
  }

  #teststatus.failures { color: red }

  .problem-tokens { border-bottom: 3px dotted red; display: inline-block; background: #fcc }

  .padded { min-width: 1em; display: inline-block; text-align: center }

  .grammar sub { font-size: 50% }

  .tnode { display:inline-block; border: 1px solid green; margin: 2px }
  .tleaf:before { content: "\201c" }
  .tleaf:after { content: "\201d" }

  div.ast {
      display: inline-block; border: 1px solid green; margin: .5em 4px 4px 4px;
      position: relative;
      line-height: normal;
  }
  div.ast > span.type {
      position: absolute; top: -.5em ;
      line-height: normal; padding: 0 2px 0 2px;
      font-size: 8px;
  }
  span.type {
      color: green; background: white;
  }
  div.ast.garbage {
      border: 1px dashed red;
      max-width: 12em;
  }
  div.ast.garbage > span.type { color: red; font-style: italic }
  div.quasi > span.type, span.type.quasi {
      /* Color quasi quotations as ice-like */
      background: #a5f2f3;
  }

  table.grammar tr > td:nth-child(2) { text-align: right }
  table.grammar, table.grammar td, table.grammar th { border: none }
  table.grammar tr { background-color: transparent }
  .nonterm:before { content: "<" }
  .nonterm:after { content: ">" }
  .nonterm { font-style: italic }
  .term:before { content: "\201c" }
  .term:after { content: "\201d" }

  #tio-input { white-space: pre-wrap }

  /* parts of speech */
  .pos-stmt { background: #fbb; border: 3px solid red }
  .pos-type { background: #bbf; border: 3px dashed blue }
  .pos-expr { background: #ff8; border: 3px double #9b870c }

  body.has-failures {
      border: 3px dashed red;
  }

  button.copy-to-tio { float: right }


  #flattening-example-table tr { background-color: transparent }
  #flattening-example-table td {
      border: 0; text-align: center;
      font-family: "Inconsolata", "Consolas", "Lucida Console", "Monaco", monospace;
  }

  dl > dt { font-style: italic }
</style>

<script src="html.js"></script>
<script>
  // Define a test harness so we can inline test results.
  function debug(statics, ...dynamics) {
    console.log(combine(statics, dynamics, (x) => JSON.stringify(x, null, 2)));
  }

  let failureCount = 0;
  let testCount = 0;

  window.onerror = () => {
    ++failureCount;
    ++testCount;
    updateTestCount();
  };

  function prettifyPrintTestInput(input) {
    if (typeof prettyPrintOne === 'function') {
      return new HTML(prettyPrintOne(String(escHtml(input))));
    }
    return input;
  }

  // Collect tests so we can run them after we've defined the machinery they depend upon
  let deferredTests = [];
  function deferTest(f) {
    if (deferredTests !== null) {
      deferredTests.push(f);
    } else {
      setTimeout(f, 0);
    }
  }

  function runDeferredTests() {
    const toRun = [...(deferredTests || [])];
    deferredTests = null;
    return Promise.all(toRun.map((f) => new Promise(
      (resolve, reject) => {
        setTimeout(() => {
          try {
            f();
          } catch (ex) {
            reject(ex);
            return;
          }
          resolve(null);
        }, 0);
      }
    )));

  }

  function test(f) {
    // Delay running the test until the scripts that define the lexer and parser run.
    deferTest(
      () => {
        let pass = true;
        try {
          pass = !!f();
        } catch (ex) {
          pass = false;
          console.error(ex);
        }

        if (!pass) {
          ++failureCount;
        }
        ++testCount;
        setTimeout(updateTestCount, 0);
      });
  }

  // Test harness for lexer
  function inlineJsonTest(
    input, want,
    {
      compute,
      formatOutput,
      formatInput = (x) => x,
      jsonReplacer = null,
    }) {
    const div = document.createElement('div');
    div.className = 'testcase';
    if (document.currentScript) {
      document.currentScript.parentNode.insertBefore(div, document.currentScript);
    } else {
      document.body.appendChild(div);
    }

    test(
      () => {
        console.group(input);
        try {
          const got = compute(input);
          let feedback = html`<button type="button" class="copy-to-tio">&#x1f4cb;</button>
<div class="input">${
  prettifyPrintTestInput(formatInput(input, got))
}</div>
${ formatOutput(got, 'actual') }`;
          const wantJSON = JSON.stringify(want, jsonReplacer);
          const gotJSON = JSON.stringify(got, jsonReplacer);
          console.log(`want ${ wantJSON }`);
          const passed = wantJSON === gotJSON;
          if (!passed) {
            console.log(`got  ${ gotJSON }`);
            div.className += ' fail';
            feedback = html`
<details><summary>${ feedback }</summary>
  ${ formatOutput(want, 'expected') }
</details>`;
            console.error('failed');
            div.id = allocateDomIdForFirstFailingTest();
          }
          div.innerHTML = feedback;
          div.querySelector('button.copy-to-tio').onclick =
            populateTryItOut.bind(null, input);
          return passed;
        } finally {
          console.groupEnd();
        }
      });
  }

  function updateTestCount() {
    const teststatus = document.getElementById('teststatus');
    teststatus.textContent = `${ failureCount } / ${ testCount } failed`;
    teststatus.className = failureCount ? 'failures' : '';
    if (domIdForFirstFailingTest) {
      teststatus.href = `#${ domIdForFirstFailingTest }`;
      teststatus.onclick = () => {
        // When the user clicks on the "1 / 12 failing" link, make
        // sure the browser can scroll to something visible.
        let failureNode = document.getElementById(domIdForFirstFailingTest);
        for (; failureNode; failureNode = failureNode.parentNode) {
          if (failureNode.open === false) {  // <details> have .open
            failureNode.open = true;
          }
        }
      };
    }

    if (failureCount) {
      document.body.classList.add('has-failures');
    } else {
      document.body.classList.remove('has-failures');
    }
  }

  const FAILING_TEST_DOMID = 'failingtest';
  let domIdForFirstFailingTest = null;
  function allocateDomIdForFirstFailingTest() {
    if (domIdForFirstFailingTest === null) {
      return domIdForFirstFailingTest = FAILING_TEST_DOMID;
    }
    return null;
  }
</script>

<script>
  // Formatting code for presenting test results to the user in HTML.

  /** Convert a parse tree to HTML by inserting <span class="tnode"> */
  function formatTNode(parseTree) {
    if (Array.isArray(parseTree)) {
      return html`<span class="tnode">${ html.join(parseTree.map(formatTNode), ', ') }</span>`;
    } else {
      return html`<span class="tleaf">${ parseTree.tok || parseTree }</span>`;
    }
  }

  function formatAst(ast) {
    if (ast && typeof ast === 'object' && !Array.isArray(ast)) {
      if (typeof ast.type === 'string' && Array.isArray(ast.children)) {
        let classes = 'ast';
        if (ast.type[0] === 'q') {
          classes += ' quasi';
        }
        return html`<div class="${ classes }"><span class="type">${ ast.type }</span>${
            html.join(ast.children.map(formatAst), ' ')
        }</div>`;
      } else if (Array.isArray(ast.discards)) {
        return html`<div class="ast garbage"><span class="type">${ ast.type || 'garbage' }</span>${
            html.join(ast.discards.map(formatToken), ', ')
        }</div>`;
      }
    }
    return html`<span class="astleaf">${ ast }</span>`;
  }

  function formatToken(x) {
    return html`<span class="token ${ x.synthetic ? 'synthetic' : '' }">
        ${ x && typeof x.tok === 'string' ? x.tok : x }
    </span>`;
  }

  function formatTokens(tokens, problem, kind) {
    return html`<div class="tokens ${ kind }">${
          html.join(tokens.map(formatToken), ', ')
        } ${ problem ? '*' : '' }</div>`
  }

  function formatProblems(problems) {
    return html`<table summary="problems" class="problem-list">
      ${ html.join(
         problems.map(({ left, right, message }) =>
           html`<tr><td>${ left }<td>${ right }<td>${ message }</tr>`),
         '') }
    </table>`;
  }

  /** Given text and a list of problems, returns HTML wiggly lines under problematic parts. */
  function wiggles(text, problems) {
    // Get a list of non-overlapping, sorted regions.
    let positions = problems.map(({ left, right }) => ({ left, right }));
    // Sort positions so that we can consume from left to right.
    positions.sort(
      ({ left: al, right: ar }, { left: bl, right: br }) => (
        al < bl ? -1 : al == bl ? ar - br : 1
      ));
    for (let i = 0; i < positions.length; ++i) {
      let { left: al, right: ar } = positions[i];
      if (i + 1 < positions.length) {
        let { left: bl, right: br } = positions[i + 1];
        if (ar >= bl) {  // overlap or intersect
          positions[i + 1] = {  // merged
            left:  Math.min(al, bl),
            right: Math.max(ar, br),
          };
          positions[i] = null;  // filtered out later
        }
      }
    }
    positions = positions.filter(x => x !== null);

    let htmlChunks = [];
    let textIndex = 0;
    for (const { left, right } of positions) {
      htmlChunks.push(
        text.substring(textIndex, left),
        html`<span class="problem-tokens">${ padIfShort(text.substring(left, right)) }</span>`,
      );
      textIndex = right;
    }
    htmlChunks.push(text.substring(textIndex));

    return html.join(htmlChunks, '');
  }

  function padIfShort(s) {
    if (s.length >= 3) { return s; }
    return html`<span class="padded">${ s }</span>`;
  }

  /** Groups adjacent tokens that have the same part-of-speech. */
  function groupPartsOfSpeech(taggedTokens) {
    const groups = [];
    for (const token of taggedTokens) {
      // Convert to simple JSON for comparison to want
      const el = { ...token, toJSON() { return this.tok } };
      if (groups.length) {
        const [gpos, group] = groups[groups.length - 1];
        if (token.pos === gpos) {
          group.push(el);
          continue;
        }
      }
      groups.push([token.pos, [el]]);
    }
    return groups;
  }

  function formatPartsOfSpeech(grouped) {
    let result = '';
    let cpos = 0;  // Insert space between non-adjacent tokens.
    for (const [pos, tokens] of grouped) {
      result = html`${ result }<span class="pos-${ pos }" title="${ pos }">`;
      for (const token of tokens) {
        const { tok, left, right, synthetic } = typeof token === 'string'
          // Worst case for wanted input
          ? { tok: token, left: NaN, right: NaN, synthetic: false }
          : token;
        const adj = left === cpos;
        cpos = right;

        result = html`${ result }${ adj ? '' : ' ' }${ synthetic ? html`<i>${ tok }</i>` : tok }`;
      }
      result = html`${ result }</span>`;
    }
    return result;
  }

  // A JSON replacer
  function replaceTokenWithTokenText(key, value) {
    if (value && typeof value === 'object' && !Array.isArray(value)
        && typeof value.tok === 'string' && typeof value.left === 'number') {
      return value.tok;
    }
    return value;
  }

  // Define test predicates.

  /** tests function lex */
  function tl(
    input, want,
    {
      hasLexErrors = false,
      preparse = (x) => x
    } = {}
  ) {
    inlineJsonTest(
      input, { tokens: want, problem: hasLexErrors },
      {
        compute(x) {
          let problem = false;
          const tokens = Array.from(preparse(lex(
            x,
            {
              onLexError() {
                problem = true;
              }
            })));
          return { tokens, problem };
        },
        formatOutput({ tokens, problem }, kind) {
          return formatTokens(tokens, problem, kind);
        },
        jsonReplacer: replaceTokenWithTokenText,
      }
    );
  }

  /** test function parse */
  function tp(input, want, { lexFn, parseFn, problems = [] } = {}) {
    const jsonReplacer = replaceTokenWithTokenText;
    inlineJsonTest(
      input, { parseTree: want, problems },
      {
        compute(x) {
          const parseTree = (parseFn || parse)(preparseTokens((lexFn || lex)(input)));
          const problems = checkParseTree(parseTree);
          return { parseTree, problems };
        },
        formatOutput(result, kind) {
          return html`<details>
  <summary>
    <span class="tree ${ kind }">${ formatTNode(result.parseTree) }</span>
  </summary>
  <div class="tree ${ kind }">${ JSON.stringify(result, jsonReplacer, 2) }</div>
</details>`;
        },
        formatInput(input, { problems }) {
          return wiggles(input, problems);
        },
        jsonReplacer,
      });
  }

  /**
   * test function wellformed.
   *
   * input - source text
   * want - array of problems like
   *    [ { left: 0, right: 10, message: 'Text relating to input.substring(0, 10)' }, ... ]
   */
  function twf(input, want, { parseFn } = {}) {
    const jsonReplacer = replaceTokenWithTokenText;
    inlineJsonTest(
      input, want,
      {
        compute (x) {
          let problems = [];
          let rawTokens = lex(
            input,
            {
              onLexError(left, right, message) {
                problems.push({ left, right, message });
              },
              emitIgnorable: true,
            });
          const ignorable = /^(?:\s|[/][/*])/;
          const filteredTokens = function *() {
            for (const token of rawTokens) {
              if (!ignorable.test(token.tok)) {
                yield token;
              } else {
                if (!isWellformedToken(token.tok)) {
                  problems.push({
                    left: token.left,
                    right: token.right,
                    message: `Malformed token`
                  });
                }
              }
            }
          }();
          const parseTree = (parseFn || parse)(preparseTokens(filteredTokens));
          problems = [...problems, ...checkParseTree(parseTree)];
          return { parseTree, problems };
        },
        formatOutput({ parseTree, problems }, kind) {
          return html`
<details>
  <summary>
    ${ wiggles(input, problems) }
    (${ problems.length } problem${ problems.length !== 1 ? 's' : '' })
  </summary>
  <div class="tree ${ kind }">${ JSON.stringify(parseTree, jsonReplacer, 2) }</div>
  ${ formatProblems(problems) }
</details>`;
        },
        jsonReplacer,
      },
    );
  }

  function ta(input, want, { start = 'program' } = {}) {
    const jsonReplacer = replaceTokenWithTokenText;
    inlineJsonTest(
      input, want,
      {
        compute(x) {
          const tokens = preparseTokens(lex(x));
          const parseTree = parse(tokens);
          const flatParseTree = flattenParseTreeToPseudoTokens(parseTree);
          const result = toyLanguageGrammar.apply(start, flatParseTree);
          return result ? result.ast : null;
        },
        formatOutput (ast, kind) {
          return html`
<details>
  <summary>
    ${ formatAst(ast && ast.length === 1 ? ast[0] : { type: 'forest', children: ast }) }
  </summary>
  <div class="tree ${ kind }">${ JSON.stringify(ast, jsonReplacer, 2) }</div>
</details>`
        },
        jsonReplacer,
      });
  }

  function tpos(input, want) {
    inlineJsonTest(
      input, want,
      {
        compute(x) {
          const tokens = preparseTokens(lex(input));
          const tagged = tagPartsOfSpeech(tokens);
          return groupPartsOfSpeech(tagged);
        },
        formatOutput(grouped, kind) {
          return html`
          <div class="parts-of-speech">
            <b>${ kind }</b>:
            ${ formatPartsOfSpeech(grouped) }
          </div>`;
        },
        jsonReplacer: replaceTokenWithTokenText,
      });
  }
</script>


<h1>Towards Homoiconicity for <code>{C.like;}</code> languages</h1>
<small><a id="teststatus"></a></small>

<p>
  Error tolerant parsing techniques for C-like languages to enable
  better tool integration, partial analysis, language extensibility,
  and meta-programming.
</p>

<p>
  <b>Keywords</b>: combinators, homoiconicity, IDE, meta-programming,
  operator-precedence, parsing, quasiquotation
</p>


<ol id="toc"></ol>

<h2 id="abstract">Abstract</h2>

<p>
  Most developers are
  <a href="https://insights.stackoverflow.com/survey/2019#technology-_-programming-scripting-and-markup-languages">familiar</a>
  with languages whorse surface syntax is "C-like": C, C++, C#, Go,
  Java, JavaScript, Perl, Rust, Scala, Swift, and TypeScript.  But the
  complexity of parsing C-like languages makes it hard to achieve what
  Lisps take for granted.
</p>

<p>
  Lisps reuse a few syntactic constructs that transparently relate to
  commonly used datatypes.  This makes it easy for programmer tools to
  deal with program fragments, for designers to extend the language
  with new special forms or macros, and for programs to manipulate
  programs as data.
</p>

<p>
  Lispers often group these benefits under the rubric of &ldquo;homoiconicity&rdquo;.
  That term has
  <a href="http://www.expressionsofchange.org/dont-say-homoiconic/">some</a>
  <a href="http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point/">problems</a>,
  so this document adopts goals attributed to homoiconicity but does
  not claims that any resulting language is homoiconic.  These goals
  include:
</p>

<ul>
  <li>
    <p>
      The coarse-grained structure of a program can be inferred
      without a grammar rule per special form.
    <p>
      This lets tools easily analyzing a fragment of a larger
      program at the lowest appropriate level of abstraction.
      For example, test coverage tools and dynamic call graph generators
      instrument programs but can often operate on a token stream.
  </li>

  <li>Common syntactic errors can be isolated to part of a parse tree.
    This is important when a developer is editing code.
    <ul>
      <li>IDEs should be able to derive some type information to
	suggest appropriate completions, even when the expression
	containing the cursor is malformed.
      <li>If an input to a REPL fails to parse, the REPL should be
	able to localize the error to a fragment, and re-present the
	input with the cursor at a convenient place.
    </ul>
    <p>
      It also lets tools provide degraded service when given a
      program that uses a new special form.
  <li>
    Program generating programs can reuse the small number of rules
    with extensions.
  </li>

  <li>
    Non-onerous syntactic constraints allow common flow-insensitive
    analyses like matching uses of symbols with declarations to be
    performed by simple tools without converting a parse tree to an
    AST or taking into account other source files.
  </li>
</ul>

<p>
  Unfortunately large grammars make it hard for tools simpler than the
  compiler to accurately deal with program fragments, to degrade
  gracefully, or to deal with code as data.  This limits a diverse
  tool ecosystems to languages with a large community that can afford
  the engineering effort.
</p>

<p>
  This document introduces a way for niche languages to use familar
  C-like syntax and hopefully still support a diverse tool ecosystem.
  Specifically it
</p>
<ul>
  <li>
    Discusses <i>developers' intuitions</i> about C-like
    languages that help them reason about partial programs, broken
    programs, or brokens with unfamiliar special forms,
  </li>
  <li>
    Formalizes those intuitions via a <i>cover grammar</i> for
    C-like statement constructs and catalogues exceptions to the
    rule,
  </li>
  <li>
    Defines an <i>operator-precedence parser</i> for C-like languages
    that reuses a small number of rules,
  </li>
  <li>
    Catalogues sources of <i>non-context-free</i>ness in some widely-used
    C-like languages, and how to avoid those in new languages,
  </li>
  <li>
    Defines a context-free <i>lexer</i> which recognizes complicated lexical
    constructs from JavaScript and Perl but which, unlike those languages,
    does not require scannerless parsing,
  </li>
  <li>
    Evaluates the same on <i>partial & broken inputs</i> to see how well it
    localizes damage to the parse tree,
  </li>
  <li>
    Catalogues the ways that a parse tree derived from a partial or
    broken input may fail generic <i>well-formedness checks</i>,
  </li>
  <li>
    Shows how <i>parser combinators</i> can be used to derive ASTs from
    parse trees, including partial or broken parse trees, for a toy language,
  </li>
  <li>
    Extends the toy language with <i>quasiquotation</i> syntax,
  </li>
  <li>
    <i>Advises</i> language implementors on how to craft a grammar to
    enable this approach.
  </li>
</ul>


<h2 id="covering-grammars">Covering Grammars</h2>


<p>
  Grammars with many, fine-grained rules can do a good job preventing
  nonsensical inputs from confusing later compiler stages, but
  typically produce either a parse tree, or error messages, not both.
</p>

<table class="grammar">
  <tr><td><span class="nonterm">Statement</span><td>::==<td><span><span class="term">for</span><td><span class="term">(</span> <span class="nonterm">Stuff</span> <span class="term">)</span> <span class="term">{</span> <span class="nonterm">Stuff</span> <span class="term">}</span></tr>
  <tr><td><td>/<span><td><span class="term">if</span><td><span class="term">(</span> <span class="nonterm">Stuff</span> <span class="term">)</span> <span class="term">{</span> <span class="nonterm">Stuff</span> <span class="term">}</span> &hellip;</tr>
  <tr><td><td>/<span><td><span class="term">while</span><td><span class="term">(</span> <span class="nonterm">Stuff</span> <span class="term">)</span> <span class="term">{</span> <span class="nonterm">Stuff</span> <span class="term">}</span></tr>
  <tr><td><td>/<span><td>&hellip;</tr>
</table>

<p>
  A large grammar like this could adapt to account for common
  developer errors and to deal with partial inputs, but this takes
  engineering effort per rule, and makes the grammar even larger.
</p>

<pre style="line-height: 1.05em">
if ( x ) { fn<span class="problem-tokens">(</span>; }

   &#x2517;&#x2501;&#x251b; &#x2503;   &#x2579; &#x2503;
         &#x2517;&#x2501;&#x2501;&#x2501;&#x251b;
</pre>

<p id="programmer-intuitions">
  A parser that degrades gracefully on inputs like the above,
  should recognize the kind of rules-of-thumb that programmers
  use to reason about broken inputs:
</p>
<ul>
  <li>like brackets pair,</li>
  <li>curlies group statements,</li>
  <li>semicolons separate statements,</li>
  <li>commas separate expressions</li>
</ul>

<p>
  The grammar above has a lot of repetition.
  In languages with C-like grammars, most of the flow control special
  forms, and some other special forms (like JavaScript's
  <code>function(...) {...}</code>) follow the
  convention:
</p>

<table class="grammar">
  <tr><td><span class="nonterm">Statement</span><td>::==<td><span><span class="nonterm">keyword</span> <span class="term">(</span> <span class="nonterm">Stuff</span> <span class="term">)</span> <span class="term">{</span> <span class="nonterm">Stuff</span> <span class="term">}</span> &hellip;</tr>
</table>

<p>
  A <i>cover grammar</i> for two grammar rules matches all strings
  matched by either rule so that a later pass can disambiguate.
  For example, consider the JavaScript expression
  <code class="prettyprint">(a = null) =&gt; (a = null)</code>.  In
  it, <code class="prettyprint">(a = null)</code> appears twice, once
  as a formal parameter list with a default value, and once as an
  assignment.  To avoid reparsing based on whether a
  <code>=&gt;</code> follows the close parenthesis, JavaScript
  engines often use a cover grammar for the <i>FormalParameterList</i>
  and <i>PrimaryExpression</i> rules.
</p>

<p>
  We can rephrase developers' intuitions about a language by
  crafting a few rules that cover the myriad rules in the full grammar.
  This lets a few error recovery strategies tuned to programmers'
  intuitions to carry much weight.
</p>

<p>
  Each of the statement types above looks like a function application
  followed by a block, but there are a some conventions which
  distinguish these from normal function calls.
</p>

<ul>
  <li>Declarations inside the parentheses, when allowed, are visible
  within the curly bracket block (<code>{&hellip;}</code>).</li>
  <li>Declarations in either are not visible outside the
    whole.
    <small>(This was not the case in
    <a href="https://stackoverflow.com/a/1287867/20394">C89 and earlier</a>
    but was
    <a href="http://port70.net/~nsz/c/c11/n1570.html#6.8.5.3p1">fixed in C99</a>
    and languages since have followed suit.)</small>
  </li>
  <li>Execution of statements in <code>{&hellip;}</code> may be executed
  late, multiply, or not at all.</li>
</ul>

<p>
  Additionally, certain keywords allow chaining these constructs, e.g.
  <span class="term">else</span>.
</p>

<p>
  A cover grammar for C-like flow control constructs is:
</p>

<table class="grammar" id="cover-grammar">
<tr><td><span class="nonterm">FlowControl</span></td>     <td>::==<td><span class="nonterm">Keyword</span> <span class="nonterm">ParenPart<sub>opt</sub></span> <span class="nonterm">Tail</span>;</tr>
<tr><td><span class="nonterm">ParenPart</span></td>       <td>::==<td><span class="term">(</span> <span class="nonterm">TokenSoup</span> <span class="term">)</span>;</tr>
<tr><td><span class="nonterm">ParenPart<sub>opt</sub></span></td><td>::==<td><span class="nonterm">ParentPart</span> / &epsilon;;</tr>
<tr><td><span class="nonterm">Tail</span><td>::==<td><span class="term">{</span> <span class="nonterm">TokenSoup</span> <span class="term">}</span> <span class="nonterm">MoreFlowControl</span></tr>
<tr><td><td>/<td><span class="term">;</span>;</tr>
<tr><td><span class="nonterm">MoreFlowControl</span></td> <td>::==<td><span class="nonterm">InfixKeyword</span> <span class="nonterm">FlowControl</span></tr>
<tr><td></td>                <td>/</td><td>&epsilon;;</tr>
<tr><td><span class="nonterm">InfixKeyword</span></td>    <td>::==<td><span class="term">else</span> <span class="term">if</span> / <span class="term">else</span> / <span class="term">catch</span> / <span class="term">finally</span>;</tr>
</table>

<p><a href="#wrinkle1">Not</a> <a href="#wrinkle2">all</a> follow this convention but
<a href="#parsing-statements">many do</a>.</p>


<p>
  This document's focuses on extensibility of statement level
  constructs, but it briefly discusses
  <a href="#custom-expression-operators">custom expression operators</a>
  as a way of using small number of rules to enable extensible
  expression grammars.  This document later outlines two
  <a href="#code-as-data">quasiquotation</a> mechanisms.
  Finally the document discusses <a href="#limitations">limitations</a>
  of this approach.
</p>


<h2 id="trees">A tale of two trees: Parse Trees, ASTs</h2>

<p>
  This document builds a parser in JavaScript so that it can run in
  your browser.
</p>

<p>
  Before jumping into code, it's worth defining some terms.
  For the purposes of this document:
</p>

<dl>
  <dt>Token</dt>
  <dd>
    A substring of a program fragment with some diagnostic metadata.
    Tokens may be malformed, e.g. an unclosed quoted string.
  </dd>

  <dt>Significant token</dt>
  <dd>A token that is not a comment or ignorable whitespace.</dd>

  <dt>Parse Tree (CST)</dt>
  <dd>
    A tree such that leaves are tokens and a preorder enumeration of
    leaves yields the significant tokens from which it was parsed.
  </dd>

  <dt>Abstract Syntax Tree (AST)</dt>
  <dd>
    A tree such that each node is either a token, or is a collection
    of sub-trees and a tag that identifies a production in the
    language's abstract grammar.

    <p>
      An AST need not contain all significant tokens, e.g. an
      implementation might drop parentheses used merely for grouping,
      or tokens like &ldquo;<tt>if</tt>&rdquo; which are implicit in
      the tag.

    <p>
      An inner AST node may have the special <i>error</i> tag in which
      case its children are a soup of tokens to which later passes should
      not assign clear semantics.
  </dd>

  <dt>Lexer</dt>
  <dd>
    Partitions source text into a stream of tokens.
  </dd>

  <dt>Parser</dt>
  <dd>
    A consumer of a stream of tokens that produces a parse tree.
  </dd>

  <dt>Combinator</dt>
  <dd>
    A consumer of a stream that builds a structured output based on
    declarative rules describing patterns involving sequences of
    stream elements.
  </dd>
</dl>

<h2 id="precedence">Precedence</h2>

<p>
  Operator precedence parsers reuse a few simple rules and an operator
  precedence grammar can embed
  <a href="#programmer-intuitions">programmers' intuitions</a> about
  the meaning of broken inputs.  Instead of having grammar rules for
  every construct, you just have a few:
</p>

<table class="grammar" id="operand-grammar">
<tr><td><span class="nonterm">Operand</span></td>     <td>::==<td><span class="nonterm">PrefixOperator</span> <span class="nonterm">Operand</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span> <span class="nonterm">InfixOperator</span> <span class="nonterm">Operand</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span> <span class="nonterm">TernaryOperator</span> <span class="nonterm">Operand</span> <span class="nonterm">TernaryFollower</span> <span class="nonterm">Operand</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span> <span class="nonterm">OpenBracket</span> <span class="nonterm">Operand</span> <span class="nonterm">CloseBracket</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span> <span class="nonterm">PostfixOperator</span></tr>
<tr><td><td>|<td><span class="nonterm">SimpleOperand</span>;</tr>
</table>

<p>
  Operator precedence parsers use &ldquo;operators&rdquo; to figure out
  how to turn a series of tokens into a tree structure.  This lets us
  infer parentheses in expressions and to identify when a keyword like
  <code>else</code> or the <code>while</code> in <code>do...while...</code>
  groups things to its immediate left and right.
  So <span class="nonterm">PrefixOperator</span> defines which operators
  can appear before their operands like the &lsquo;-&rsquo; in
  &ldquo;<code>-x</code>&rdquo;;
  <span class="nonterm">InfixOperator</span> defines which can appear
  in the middle like the &lsquo;+&rsquo; in
  &ldquo;<code>x+y</code>&rdquo;.
</p>

<p>
  An operator precedence parser still needs to decide how to group
  operands: for example, if
  <span class="nonterm">InfixOperator</span>::==<span class="term">+</span>|<span class="term">&times</span>;
  then na&iuml;vely applying the grammar above to
  &ldquo;<code>a&times;b+c</code>&rdquo; would give two possible
  inerpretations: <i>(a&times;b)+c</i> and <i>a&times;(b+c)</i>.
</p>

<p>
  Operator precedence parsers use an order over operators to avoid
  ambiguity.  This order gives <i>precedence</i> to some operators
  and answers the question &ldquo;Can this operator contain that
  operator unparenthesized?&rdquo; For example, if &lsquo;+&rsquo; can
  contain &lsquo;&times;&rsquo; unparenthesized but not vice versa
  then valid interpretations of &ldquo;<code>a&times;b+c</code>&rdquo;
  include
  <i>(a&times;b)+c</i> but not <i>a&times;(b+c)</i>.
</p>

<p>
  Here is an operator precedence table similar to those that appear in
  user-documentation for <a href="https://en.cppreference.com/w/c/language/operator_precedence">C</a>, <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html">Java</a> (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.2">normative</a>), and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">JavaScript</a> which gives a
  foundation for our precedence relation.
</p>

<script class="visible">
// An operator has
//   tok       : string   - a token
//   prec      : number   - a precedence value.  Higher binds more tightly.
//   type      : string   - the type of operator in (INFIX, POSTFIX, PREFIX).
//   assoc     : string   - associativity in (LEFT, RIGHT)
//   followers : string[] - for ternary ops, tokens that continue the operation.
//   closer    : boolean  - true iff the operator requires a close bracket.

// Operator types
const INFIX   = 'INFIX';
const POSTFIX = 'POSTFIX';
const PREFIX  = 'PREFIX';
const TOKEN   = 'TOKEN';  // Distinguishes leaf nodes from operator nodes.

// Associativities
const LEFT    = 'LEFT';
const RIGHT   = 'RIGHT';

// A nullary op is an operator that, by itself can have
// no arguments.
// ';' can be a postfix operator with one argument, or,
// as a NOOP statement, a zero argument operator.
// In a list like `[,]`, comma is a nullary op.
const nullaryOps = new Set([';', ',']);

const operators = [
  { tok: '.',       prec: 18, type: INFIX,   assoc: LEFT },
  // Bracket operators are groups by themselves.
  { tok: '(',       prec: 18, type: PREFIX,                closer: true },
  { tok: '{',       prec: 18, type: PREFIX,                closer: true },
  { tok: '[',       prec: 18, type: PREFIX,                closer: true },
  // Used infix, a bracket is like a function call.
  { tok: '(',       prec: 18, type: INFIX,   assoc: LEFT,  closer: true },
  // See '{...}' farther down
  { tok: '[',       prec: 18, type: INFIX,   assoc: LEFT,  closer: true },

  { tok: '++',      prec: 17, type: POSTFIX },
  { tok: '--',      prec: 17, type: POSTFIX },

  { tok: '++',      prec: 16, type: PREFIX },
  { tok: '--',      prec: 16, type: PREFIX },
  { tok: '+',       prec: 16, type: PREFIX },
  { tok: '-',       prec: 16, type: PREFIX },
  { tok: '!',       prec: 16, type: PREFIX },
  { tok: '~',       prec: 16, type: PREFIX },
  // Pointer/reference prefix operators in C++, Go, Rust.
  { tok: '&',       prec: 16, type: PREFIX },
  { tok: '*',       prec: 16, type: PREFIX },

  // There is another flavour of '<' below.  See "Less-than ambiguity".
  { tok: '<',       prec: 15, type: INFIX,   assoc: LEFT,  closer: true },
  { tok: 'new',     prec: 15, type: PREFIX },
  // TODO: 'extends', 'instanceof', 'as' probably go here.

  { tok: '**',      prec: 14, type: INFIX,   assoc: LEFT },

  { tok: '*',       prec: 13, type: INFIX,   assoc: LEFT },
  { tok: '/',       prec: 13, type: INFIX,   assoc: LEFT },
  { tok: '&',       prec: 13, type: INFIX,   assoc: LEFT },

  { tok: '+',       prec: 12, type: INFIX,   assoc: LEFT },
  { tok: '-',       prec: 12, type: INFIX,   assoc: LEFT },

  { tok: '<<',      prec: 11, type: INFIX,   assoc: LEFT },
  { tok: '>>',      prec: 11, type: INFIX,   assoc: LEFT },
  { tok: '>>>',     prec: 11, type: INFIX,   assoc: LEFT },

  { tok: '<',       prec: 10, type: INFIX,   assoc: LEFT },
  { tok: '<=',      prec: 10, type: INFIX,   assoc: LEFT },
  { tok: '>',       prec: 10, type: INFIX,   assoc: LEFT },
  { tok: '>=',      prec: 10, type: INFIX,   assoc: LEFT },
  { tok: 'in',      prec: 10, type: INFIX,   assoc: LEFT },

  { tok: '==',      prec: 9,  type: INFIX,   assoc: LEFT },
  { tok: '!=',      prec: 9,  type: INFIX,   assoc: LEFT },
  { tok: '===',     prec: 9,  type: INFIX,   assoc: LEFT },
  { tok: '!==',     prec: 9,  type: INFIX,   assoc: LEFT },

  { tok: '&',       prec: 8,  type: INFIX,   assoc: LEFT },

  { tok: '^',       prec: 7,  type: INFIX,   assoc: LEFT },

  { tok: '|',       prec: 6,  type: INFIX,   assoc: LEFT },

  { tok: '&&',      prec: 5,  type: INFIX,   assoc: LEFT },

  { tok: '||',      prec: 4,  type: INFIX,   assoc: LEFT },

  // A ternary operator.
  { tok: '?',       prec: 3,  type: INFIX,   assoc: RIGHT, followers: [ ':' ] },
  { tok: ':',       prec: 3,  type: INFIX,   assoc: RIGHT },
  // Infix '{' is used in keyword (expression) { statements; }
  { tok: '{',       prec: 3,  type: INFIX,   assoc: RIGHT, closer: true },

  // Equality operators
  { tok: '=',       prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '+=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '-=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '*=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '/=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '%=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '&=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '^=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '|=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '&&=',     prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '||=',     prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '<<=',     prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '>>=',     prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '>>>=',    prec: 2,  type: INFIX,   assoc: RIGHT },

  // Appears in variadic signatures and in array/object creation.
  { tok: '...',     prec: 1,  type: PREFIX,  assoc: RIGHT },

  // Comma is an odd ducks since they separate non-expression
  // productions that themselves contain expressions, e.g. in
  // formal argument lists and variable declaration lists in
  // many languages.
  { tok: ',',       prec: 0,  type: INFIX,   assoc: RIGHT },
];
</script>

<p>
  We need to be able to match up brackets.
</p>

<script class="visible">
const bracketPartners = new Map([
  [ '(', ')' ],
  [ '{', '}' ],
  [ '[', ']' ],
  [ '<', '>' ],
]);
</script>

<script class="visible hoisted" id="extra-brackets-for-quasis">
// Extra brackets for quasi-quoting
bracketPartners.set('\\{', '}');
bracketPartners.set('\\(', ')');
bracketPartners.set('${', '}');
operators.push(
  { tok: '\\(',     prec: 18, type: PREFIX,                closer: true },
  { tok: '\\{',     prec: 18, type: PREFIX,                closer: true },
  { tok: '${',      prec: 18, type: PREFIX,                closer: true },
);
</script>

<p>
  Some derived tables simplify later code greatly.
</p>

<script class="visible">
const openBrackets  = new Set();
const closeBrackets = new Set();
for (const [ open, close ] of [...bracketPartners.entries()]) {
  openBrackets.add(open);
  closeBrackets.add(close);
}
</script>


<p>These operatores give arithmetic & logical expressions theit usual
meanings.</p>

<script>
  tp('1 - 1 - 1', [ [ [ '1' ], '-', [ '1' ] ], '-', [ '1' ]]);
  tp('1 - 1 * 1', [ [ '1' ], '-', [ [ '1' ], '*', [ '1' ] ] ]);
  tp('1 * 1 - 1', [ [ [ '1' ], '*', [ '1' ] ], '-', [ '1' ] ]);
  tp('a = b = c', [ [ 'a' ], '=', [ [ 'b' ], '=', [ 'c' ] ] ]);
  tp('!!b', [ '!', [ '!', [ 'b' ] ] ]);
  tp('a && b || c == d', [ [ ['a'], '&&', ['b']], '||', [['c'], '==', ['d'] ]]);
</script>

<p>
  Note: Herein, parse trees are shown with a rectangle around each
  inner node.  Click the expando (&#x25b6;) to see an indented view of
  the same.  These diagrams are generated programatically by the
  described parser running as JavaScript in your browser.
</p>

<h3 id="less-than-ambiguity">Less-than ambiguity</h3>

<p id="bracket-ambig">There is a deep, unavoidable ambiguity in C++,
Java, and probably Rust.  A &lsquo;&lt;&rsquo; token may be either
infix operator less-than or the start of an angle bracketed group of
type parameters.  Consider the partial token sequence &hellip;
<code class="prettyprint">f ( a &lt; b , c &gt; d )</code>
&hellip; in Java:</p>

<pre class="prettyprint lang-java">
public &lt;b, c&gt; int <u>f(a&lt;b, c&gt; d)</u> {
  //   &#x21e7;   &#x21e7;       &#x21e7;   &#x21e7;
  // Angle brackets group type parameters in a method signature.

  return d.<u>f(a &lt; b, c &gt; d)</u>;
  //           &#x21e7;     &#x21e7;
  // Using less than, greater than to compute actual
  // parameters.
}
</pre>

<p>This is a real problem and this document only provides a partial
solution to this ambiguity.  We take a cue from TypeScript which
allows types (and hence type parameters) in a few readily identifiable
contexts:
</p>
<ul>
  <li>As the right operand of a few infix operators like
    &lsquo;:&rsquo;, &ldquo;as&rdquo;, &ldquo;extends&rdquo;,
    &ldquo;instanceof&rdquo;, and &ldquo;new&rdquo;.
    Since <a href="#colon-meanings">&lsquo;:&rsquo; can precede
    labeled statements</a> this may not be perfect.
  <li>As the right operand of &lsquo;=&rsquo; when it appears in
    a &ldquo;type&rdquo; declaration.</li>
  <li>In deprecated <code>&lt;typecast&gt;</code> syntax which we
    ignore.</li>
</ul>

<p>
  Here's how things parse when our operator precedence function uses
  only allows <code>&lt;&hellip;&gt;</code> to the right of the
  operators listed above.
</p>

<script>
  tp(
    'f(a<b, c>d)',
    [
      ['f'],
      '(',
      [
        [['a'], '<', ['b']],
        ',',
        [['c'], '>', ['d']],
      ],
      ')',
    ]
  );
  tp(
    'f(d: a<b, c>)',
    [
      ['f'],
      '(',
      [
        ['d'],
        ':',
        [
          ['a'],
          '<',
          [
            ['b'],
            ',',
            ['c'],
          ],
          '>',
        ],
      ],
      ')',
    ]
  );
  tp(
    `\
// multiple closers in  '>>='
let a: Array<Array<number>>= [[]];`,
    [
      [
        [
          ['let', 'a'],
          ':',
          [
            ['Array'],
            '<',
            [
              ['Array'],
              '<',
              ['number'],
              '>',
            ],
            '>',
          ],
        ],
        '=',
        [
          '[',
          [
            '[',
            ']',
          ],
          ']',
        ],
      ],
      ';',
    ],
  );
tp(
  'boolean x = a ? a : b < c && c > d;',
  [
    [
      ['boolean', 'x'],
      '=',
      [
        ['a'],
        '?',
        ['a'],
        ':',
        [
          [['b'], '<', ['c']],
          '&&',
          [['c'], '>', ['d']],
        ],
      ],
    ],
    ';',
  ],
);
tp(
  'type nums = Set<number>;',
  [
    [
      ['type', 'nums'],
      '=',
      [
        ['Set'],
        '<',
        ['number'],
        '>',
      ],
    ],
    ';',
  ]
);
</script>

<p>Note: <a href="https://facebook.github.io/jsx/#syntax"><i>JSXElement</i>s</a>
like (<code class="prettyprint">image = &lt;img src={src}&gt;</code>)
do not require parse-time disambiguation.  The code herein does not
handle JSX, but later sections introduce mechanisms that should extend
to that use case.  Specifically, <a href="#lexing">lexing</a> explains
how to use one token of lookbehind to decide whether &lsquo;/&rsquo;
starts a division operator or a regular expression literal.  A similar
approach could decide whether a &lsquo;&lt;&rsquo; starts an operator
or a JSX block.  Also, <a href="#token-preparsing">preparsing</a>
talks about a technique to group template literal parts which would
help handle JSX.</p>

<details>
  <summary>Dead-end: &ldquo;Part-of-speech&rdquo; tagging</summary>

  <h4 id="part-of-speech-tagger">Dead-end: &ldquo;Part-of-speech&rdquo; tagging</h4>

  <p>
    This approach was found to be brittle, and hard to build confidence in.
    It is included to document a dead-end.
  </p>

<p>It may be possible to resolve ambiguities, like angle bracket ambiguity,
would be to provide additional context cues to the parser.</p>

<p>A <i>part-of-speech tagger</i> could run as a part of the pre-parse
processing pass over tokens to add context usable by the operator precedence
function.  Parts of speech might include:</p>

<ul>
  <li>An <span class="pos-expr">expression</span> is entered on
  &lsquo;(&rsquo;, &lsquo;[&rsquo;, &lsquo;=&rsquo; (reset by
  &lsquo;,&rsquo;), &lsquo;;&rsquo; in parens</li>
  <li>A <span class="pos-stmt">statement</span> is entered on statement
  keyword or &lsquo;;&rsquo; not in parens.
  <li>A <span class="pos-type">type</span> is entered on &lsquo;as&rsquo;
  (TypeScript infix cast operator) or &lsquo;:&rsquo; in parens or
  following declaration keyword, but not following
  &lsquo;?&rsquo;</li>
</ul>

<p>This example shows two distinct uses of &lsquo;&lt;&rsquo;: once to
bracket type parameters, and later as a comparison operator.  It also
shows three distinct uses of &lt;{&gt;: first to start a statement
block, then o bracket a record type, and finally to construct a
record.</p>

<p>An operator precedence function that used part-of-speech cues could
assign different precedences to these different uses.</p>

<script>
  tpos(
    '{ let o : { x: (T<P> | null) } = { x: a < b && c > d ? f() : g() }; }',
    [
      ['stmt', ['{', 'let', 'o']],
      ['type', [':', '{', 'x', ':', '(', 'T', '<', 'P', '>', '|', 'null', ')', '}']],
      ['expr', ['=', '{', 'x', ':', 'a', '<', 'b', '&&', 'c', '>', 'd',
                '?', 'f','(', ')', ':', 'g', '(', ')', '}']],
      ['stmt', [';', '}']],
    ]
  );
  tpos(
    'a = new T<A, B<C, D>, E>(a<b, c>d).foo();\nlbl: function f(x:T=null) : bool { return x instanceof Object; }',
    [
      ['stmt', ['a']],
      ['expr', ['=', 'new']],
      ['type', ['T', '<', 'A', ',', 'B', '<', 'C', ',', 'D', '>', ',', 'E', '>']],
      ['expr', ['(', 'a', '<', 'b', ',', 'c', '>', 'd', ')']],
      ['stmt', ['.', 'foo']],
      ['expr', ['(', ')']],
      ['stmt', [';', 'lbl', ':', 'function', 'f']],
      ['expr', ['(', 'x']],
      ['type', [':', 'T']],
      ['expr', ['=', 'null', ')']],
      ['type', [':', 'bool']],
      ['stmt', ['{', 'return']],
      ['expr', ['x', 'instanceof']],
      ['type', ['Object']],
      ['stmt', [';', '}']],
    ]
  );
  tpos(
    'new A(a < b, c > d);',
    [
      ['stmt', ['new']],
      ['type', ['A']],
      ['expr', ['(', 'a', '<', 'b', ',', 'c', '>', 'd', ')']],
      ['stmt', [';']],
    ]
  );
</script>

<p>Here's a tagger that seems to work well for TypeScript, but is brittle.</p>

<script class="visible">
/** Given a series of tokens, returns the same series but with a pos field. */
function *tagPartsOfSpeech(tokens) {
  const contextStack = [
    {
      closer: null,  // Token text that pops this element
      pos: 'stmt',   // The part of speech
      pos0: 'stmt',  // Part of speech returned to on ','
      oncolon: null,  // What to do on a colon
      oncolon0: null,
    },
  ];
  // Keep two tokens worth of lookbehind
  let lookbehind0 = null;
  let lookbehind1 = null;
  for (const token of tokens) {
    const { tok } = token;
    const { length: n } = contextStack;
    let top = contextStack[n - 1];
    let { pos } = top;
    switch (tok) {
    case '(': case '[': case '{':
      let oncolon = null;
      let pos0 = null;
      if (tok === '{') {
        if (pos === 'expr') {
          if (lookbehind0 === '=>') {
            pos = 'stmt';
          } else {
            oncolon = 'expr';
          }
        } else if (pos === 'type'
                   && !(lookbehind0 === '|' || lookbehind0 === ':'
                       || lookbehind0 === ',' || lookbehind0 === '<')) {
          pos = top.pos0;
        }
      } else if (lookbehind0 === 'for' && tok === '(') {
        pos0 = 'expr';
        pos = 'stmt';
      } else if (tok === '(' && pos === 'type'
                 && lookbehind0 !== '|' && lookbehind0 !== '<'
                 && lookbehind0 !== ',' && lookbehind0 !== ':') {
        pos = 'expr';
      } else if (pos === 'stmt') {
        pos = 'expr';
      }
      contextStack.push({
        closer: bracketPartners.get(tok),
        pos,
        pos0: pos0 || pos,
        oncolon0: null,
        oncolon,
      });
      break;
    case '}': case ']': case ')': case '>':
      for (let i = n; --i > 0;) {
        if (tok === contextStack[i].closer) {
          contextStack.length = i;
          break;
        }
      }
      break;
    case '<':
      if (pos === 'type') {
        top.pos = top.pos0;
        contextStack.push({
          closer: '>',
          pos,
          pos0: pos,
          oncolon0: null,
          oncolon: null,
        });
      }
      break;
    case ':':
      if (pos === 'stmt' && WORD_RE.test(lookbehind0)
          && (lookbehind1 === null || lookbehind1 === ';'
              || lookbehind1 === '}')) {
        // Labeled statement
      } else {
        pos = top.pos = top.oncolon || 'type';
      }
      break;
    case '=':
      pos = top.pos = 'expr';
      break;
    case ';': case ',':
      pos = top.pos = top.pos0;
      top.oncolon = top.oncolon0;
      break;
    case '?':
      contextStack[n - 1].oncolon = 'expr';
      break;
    // Keywords
    case 'as': case 'instanceof': case 'extends': case 'new':
      top.pos = 'type';
      break;
    case 'assert': case 'return': case 'throw': case 'yield':
      top.pos = 'expr';
      break;
    case 'case': case 'default':
      top.pos = top.pos0 = 'expr';
      top.oncolon = top.oncolon0 = 'stmt';
      break;
    }
    yield { ...token, pos };
    lookbehind1 = lookbehind0;
    lookbehind0 = tok;
  }
}
</script>

<p>This tagger is a fairly complicated push-down automaton, but
languages for which it's possible to specify may be able to exploit
that fact to simplify their precedence functions.</p>

</details>


<h3 id="flow-control-joiners">Flow control joiners</h3>

<p>Besides that, expressions in C-like languages are a good fit for
precedence tables like this.  It turns out that statements can be
shoe-horned in with a wrinkle though.
As <a href="#cover-grammar">discussed</a>, most flow control
constructs in C-like languages have the form <code>keyword (expression)
statement</code>.</p>

<p>There are a few keywords that precede blocks but that always follow
statements.  And &lsquo;<code>;</code>&rsquo; separates statements.</p>

<script class="visible">
operators.push(
  { tok: 'else',    prec: -1, type: INFIX,   assoc: RIGHT },
  { tok: 'catch',   prec: -1, type: INFIX,   assoc: LEFT },
  { tok: 'finally', prec: -1, type: INFIX,   assoc: LEFT },

  { tok: ';',       prec: -2, type: POSTFIX, assoc: RIGHT },
);
</script>

<h3 id="statement-parsing">Statement parsing</h3>
<p id="parsing-statements">With this, we're ready to parse some statements.</p>

<script>
  tp(
    'if (e) { stmt }',
    [
      [
        [ 'if' ],
        '(',
        [ 'e' ],
        ')',
      ],
      '{',
      [ 'stmt' ],
      '}',
    ]
  );
  tp(
    'if (e) { stmt } else { stmt }',
    [
      [
        [
          [ 'if' ],
          '(',
          [ 'e' ],
          ')',
        ],
        '{',
        [ 'stmt' ],
        '}',
      ],
      'else',
      [
        '{',
        [ 'stmt' ],
        '}',
      ],
    ]
  );
  tp(
    'while (e) { stmt }',
    [
      [
        [ 'while' ],
        '(',
        [ 'e' ],
        ')',
      ],
      '{',
      [ 'stmt' ],
      '}',
    ]
  );
  tp(
    'for (e;e;e) { stmt }',
    [
      [
        [ 'for' ],
        '(',
        [
          [ 'e' ],
          ';',
        ],
        [
          [ 'e' ],
          ';',
        ],
        [ 'e' ],
        ')',
      ],
      '{',
      [ 'stmt' ],
      '}',
    ]
  );
  tp(
    'for (t e in e) { stmt }',
    [
      [
        [ 'for' ],
        '(',
        [
          [ 't', 'e' ],
          'in',
          [ 'e' ],
        ],
        ')',
      ],
      '{',
      [ 'stmt' ],
      '}',
    ]
  );
  tp(
    'try (decl) { stuff }',
    [
      [
        [ 'try' ],
        '(',
        [ 'decl' ],
        ')'
      ],
      '{',
      [ 'stuff' ],
      '}'
    ]
  );
  tp(
    'try (decl) { stuff } catch (e) { stuff } finally { stuff }',
    [
      [
        [
          [
            [ 'try' ],
            '(',
            [ 'decl' ],
            ')'
          ],
          '{',
          [ 'stuff' ],
          '}'
        ],
        'catch',
        [
          [
            '(',
            [ 'e' ],
            ')'
          ],
          '{',
          [ 'stuff' ],
          '}'
        ]
      ],
      'finally',
      [
        '{',
        [ 'stuff' ],
        '}'
      ]
    ]
  );
  tp(
    'function (a,b,c) { stuff }',
    [
      [
        [ 'function' ],
        '(',
        [
          [ 'a' ],
          ',',
          [
            [ 'b' ],
            ',',
            [ 'c' ]
          ],
        ],
        ')'
      ],
      '{',
      [ 'stuff' ],
      '}'
    ]
  );
  tp(
    'with (x) { stuff() }',
    [
      [
        [ 'with' ],
        '(',
        [ 'x' ],
        ')'
      ],
      '{',
      [
        [ 'stuff' ],
        '(',
        ')',
      ],
      '}'
    ]
  );
  tp(
    '{}',
    [
      '{',
      '}',
    ]
  );
  tp(
    '{;}',
    [
      '{',
      [ ';' ],
      '}',
    ]
  );
  tp(
    '{f();}',
    [
      '{',
      [
        [
          [ 'f' ],
          '(',
          ')',
        ],
        ';',
      ],
      '}',
    ]
  );
</script>

<h3 id="do-hellip-while">do&hellip;while</h3>
<p id="wrinkle2">Except that in <code>do{...}while(...);</code>
the <code>while</code> appears like an infix operator, but only directly
inside a <code>do</code> which acts like a prefix operator.</p>

<script class="visible">
// LATER: some special precedence handling when a while follows a do.
operators.push(
  { tok: 'do',      prec: -1, type: PREFIX,  assoc: LEFT },
  { tok: 'while',   prec: -1, type: INFIX,   assoc: LEFT },
);
</script>

<script>
  tp(
    'do { stuff } while (!done);',
    [
      [
        [
          'do',
          [
            '{',
            [ 'stuff' ],
            '}',
          ],
        ],
        'while',
        [
          '(',
          [
            '!',
            [ 'done' ]
          ],
          ')'
        ],
      ],
      ';',
    ]
  );
</script>

<h3 id="flavours-of-colon">Flavours of colon</h3>

<p id="colon-meanings">Also, &lsquo;:&rsquo; is odd.  It seems to have
widely distinct precedences:</p>

<ul>
  <li>Paired with a &lsquo;?&rsquo; it acts as part of a ternary operator.
    <script>
  tp(
    'x = a ? b : c ? d : e;',
    [
      [
        [ 'x' ],
        '=',
        [
          [ 'a' ],
          '?',
          [ 'b' ],
          ':',
          [
            [ 'c' ],
            '?',
            [ 'd' ],
            ':',
            [ 'e' ],
          ]
        ]
      ],
      ';'
    ]
  );
  tp(
    'x = a ? b ? c : d : e;',
    [
      [
        [ 'x' ],
        '=',
        [
          [ 'a' ],
          '?',
          [
            [ 'b' ],
            '?',
            [ 'c' ],
            ':',
            [ 'd' ],
          ],
          ':',
          [ 'e' ],
        ]
      ],
      ';'
    ]
  );
    </script>
  </li>
  <li id="wrinkle1">After <code>case</code> or <code>default</code> it acts as a postfix
    operator and terminates any expression.
    <script>
  tp(
    'switch (e) { case 0: stuff; default: break; }',
    [
      [
        [ 'switch' ],
        '(',
        [ 'e' ],
        ')'
      ],
      '{',
      [
        [
          'case',
          [ '0' ],
        ],
        ':',
      ],
      [
        [ 'stuff' ],
        ';',
      ],
      [
        [ 'default' ],
        ':',
      ],
      [
        [ 'break' ],
        ';',
      ],
      '}'
    ]
  );
    </script>
  </li>
  <li>It separates a label from a statement.
    <script>
  tp(
    'label: for (;;) {}',
    [
      [ 'label' ],
      ':',
      [
        [
          [ 'for' ],
          '(',
          [
            [ ';' ],
            ';'
          ],
          ')',
        ],
        '{',
        '}',
      ],
    ]
  );
    </script>
  </li>
  <li>In TypeScript it precedes types.
    <script>
  tp(
    'const x : {} = {};',
    [
      [
        [
          [ 'const', 'x' ],
          ':',
          [ '{', '}' ],
        ],
        '=',
        [
          '{',
          '}',
        ]
      ],
      ';',
    ]
  );
    </script>
  </li>
</ul>

<script class="visible">
// LATER: special precedence handling when a colon terminates a
// case or default clause.
operators.push(
  { tok: 'case',    prec: -3, type: PREFIX },
  { tok: 'default', prec: -3, type: PREFIX },
  // Only allowed in case or default.
  { tok: ':',       prec: -3, type: POSTFIX },
);
</script>

<h3 id="infix-curly-brackets">Infix curly brackets</h3>

<p>
  There's one more wrinkle.  In <code class="prettyprint">keyword
  (expr) { stmt; }</code>, the <code>{}</code>s act as an infix
  operator like the <code>()</code>s.  This is not what we want for
  the second pair of <code>{}</code>s in <code>while (b) {x} {y}</code>.
  In C-like languages, <code>{y}</code> is a block that
  executes separately from, and after the <code>while</code>
  construct.  So we will disallow chaining of <code>{}</code> as an
  infix operator.
</p>

<script>
  tp(
    'while (b) {} {}',
    [
      [
        [
          [ 'while' ],
          '(',
          [ 'b' ],
          ')'
        ],
        '{',
        '}',
      ],
      [
        '{',
        '}'
      ]
    ]
  );
</script>

<h3 id="expression-preceding-keywords">Expression preceding keywords</h3>

<p>
  Defining prefix operators for keywords like <code>return</code>
  that precede bare expressions ensures we won't get a different parse tree
  depending on whether parentheses are present, and <code>return-1</code>
  won't parse to infix &lsquo;-&rsquo; as it should in <code>x-1</code>.
</p>

<script class="visible">
operators.push(
  { tok: 'assert',  prec: -1, type: PREFIX },
  { tok: 'return',  prec: -1, type: PREFIX },
  { tok: 'throw',   prec: -1, type: PREFIX },
  { tok: 'yield',   prec: -1, type: PREFIX },
);
</script>

<script>
  tp(
    'return x;',
    [
      ['return', ['x']],
      ';',
    ]
  );
  tp(
    'return (x);',
    [
      [
        'return',
        [
          '(',
          [ 'x' ],
          ')',
        ],
      ],
      ';',
        ]
  );
  tp(
    'return;',
    [
      ['return'],
      ';',
    ]
  );
  tp(
    'return -1;',
    [
      [
        'return',
        [
          '-',
          ['1'],
        ],
      ],
      ';',
    ]
  );
  tp(
    'x -1;',
    [
      [
        ['x'],
        '-',
        ['1'],
      ],
      ';',
    ]
  );
  tp(
    'throw e || new Error();',
    [
      [
        'throw',
        [
          ['e'],
          '||',
          [
            [
              'new',
              ['Error'],
            ],
            '(',
            ')',
          ],
        ],
      ],
      ';',
    ]
  );
  tp(
    'throw;',
    [
      [
        'throw',
      ],
      ';',
    ],
    { problems: [ { left: 0, right: 5, message: 'Missing operand' } ] },
  );
</script>

<h3 id="an-operator-precedence-function">An operator precedence function</h3>
<p>
  Knowing all this, we're ready to craft our answer to
  &ldquo;Can this operator contain that one unparenthesized?&rdquo;:
</p>

<script class="visible">
// A bogus operator which can be outer to anything.
// This lets us start parsing.
const rootOperator  = { tok: '',   prec: -(1 << 30), type: PREFIX };
// A bogus operator for nodes like numbers, identifiers, string literals.
const notAnOperator = { tok: null, prec: +(1 << 30), type: TOKEN };

/**
 * Given operators, true when an operator stack consisting of
 * outers can contain the inner operator.
 *
 * @param inner a stack element.
 * @param outers a function such that
 *    outers(0) is the stack element that would directly contain inner,
 *    outers(n + 1) contains outers(n) or is null.
 */
function canNest(outers, inner) {
  if (inner.op === rootOperator) {
    // The root can't nest in anything.
    return false;
  }

  const outer = outers(0);
  if (isNullary(outer)) {
    // Can't nest in something that takes zero operands.
    return false;
  }

  // Make sure that at most one flavour of '<' is allowed.
  if (inner.op.tok === '<'
      // If there's no node content, then we're asking whether
      // this can go in outer, not whether something can go
      // in it.
      && inner.node.length === 0) {
    if (isTypeContext(outers) === !inner.op.closer) {
      return false;
    }
  }

  // do{...}while(...); is weird.
  if (outer.op.tok === 'while') {
    return inner.op.tok === 'do' || inner.op.tok === '(';
  }

  // postfix : is only allowed to wrap 'case' and 'default'.
  if (outer.op.tok === ':' && outer.op.type === POSTFIX) {
    return inner.op.tok === 'case' || inner.op.tok === 'default';
  }

  // Chained applications of infix {} is a problem for
  //     while(b) {...}
  //     {...}
  if (outer.op.tok === '{' && openBracketCount(outer) === 0
      && inner.op.tok === '{' && outer.node.length === 0) {
    return false;
  }

  if (outer.op.closer && outer.node.length) {
    // Open brackets can contain anything.
    // Completed bracket operators can't contain anything.
    return needsCloseBracket(outer);
  }

  // new is a prefix operator, but we want function application
  // to apply to it as a whole, not just its type argument.
  // This avoids problems over function application having high
  // precedence, but type operators like <...> having lower precedence.
  if (inner.op.tok === 'new' && inner.node.length
      && outer.op.tok === '(' && !outer.node.length
      && outer.op.type === INFIX) {
    return true;
  }

  // Normal operator precedence comparison.
  if (outer.op.prec < inner.op.prec) {
    return true;
  }

  // Handle associative operators.
  if (outer.op.prec === inner.op.prec
      && (outer.op.assoc !== RIGHT
          // Parser calls canNest twice for infix operators since
          // it inserts between existing elements of the operator
          // stack, but we only need to check associativity once.
          || (inner.op.type === INFIX && inner.node.length === 0))) {
    return true;
  }

  return false;
}

/**
 * Per less-than ambiguity, <...> can
 *   +  appear in a ':' operator (e.g. `id : type<...>`),     or
 *   +  appear to the right of 'new', 'instanceof', 'as',     or
 *   +  nest in itself (e.g. `type<type<...>>`),              or
 *   +  nest in parentheses (e.g. `(type<...>)`),             or
 *   +  nest in `|` (e.g. `type0 | type1<...>`),              or
 *   +  nest in ',' (e.g. `type<param0<...>, param1<...>>`)   or
 *   +  appear to the right of certain '=', (e.g. `type t = u<...>`.
 */
function isTypeContext(outers) {
  for (let depth = 0;; ++depth) {
    const ancestor = outers(depth);
    if (!ancestor) {
      return false;
    }
    const { tok } = ancestor.op;
    if (tok === ':' || tok === 'new' /* TODO: etc. */) {
      return true;
    }
    if (tok === '=') {
      // Expect ancestor.node to be  something like ['type', 'name']
      return ancestor.node[0] && ancestor.node[0][0]
          && ancestor.node[0][0].tok === 'type';
    }
    if (tok === '|' || tok === ','
        || (tok === '(' && ancestor.op.type === INFIX)
        || (tok == '<' && ancestor.op.closer)) {
      continue;
    }
    break;
  }
  return false;
}
</script>

<p>Some bookkeeping functions help us juggle brackets.</p>

<script class="visible">
/**
 * A node "needs" a close bracket if it has an open bracket like '('
 * without a corresponding ')'.
 *
 * This tests whether the count of open brackets exceeds the count
 * of close brackets without worrying about whether open parenthesis ('(')
 * pairs properly close square (']').
 *
 * For example, these need a close
 *   foo(x   // An incomplete application of an infix bracket operator
 *   [       // An incomplete prefix bracket operation
 *   { stmt  // Another incomplete prefix bracket operation with one operand.
 * but these do not
 *   foo(x)
 *   []
 *   { stmt }
 *   [ 0 , 1 )
 *   ( ) )   // Extra closed does not need a close
 */
function needsCloseBracket(stackElement) {
  return openBracketCount(stackElement) > 0;
}

/**
 * The count of open brackets minus the count of close brackets.
 *
 * Returns resultIfNegative if it is not undefined and any prefix
 * of tokens contains more close brackets than open brackets.
 */
function openBracketCount(
    { node, op: { tok, closer } },
    resultIfNegative = undefined
) {
  if (!closer) {
    // This returns a sensible value for non bracket operators, including
    // infix '<' (less than operator) which needs to be treated differently
    // from angle brackets used in types like `T<X>`.
    return 0;
  }
  let count = 0;
  for (const { tok } of node) {
    if (closeBrackets.has(tok)) {
      --count;
      if (count < 0 && resultIfNegative !== undefined) {
        return resultIfNegative;
      }
    } else if (openBrackets.has(tok)) {
      ++count;
    }
  }
  return count;
}

/** True iff the given stack element is a nullary operation. */
function isNullary({ node, op }) {
  return op === notAnOperator
      && node.length === 1 && nullaryOps.has(node[0].tok);
}
</script>

<h3 id="separators">Separators</h3>

<p>
  This works pretty well but there are a few quirks worth mentionining.
</p>

<p>
  In <code>f(actual<sub>0</sub>, actual<sub>1</sub>,
    actual<sub>2</sub>)</code> there are nested infix commas
  (<code>,</code>) which will later require a bit of work in the
  grammar (<a href="#toy-grammar">see <code>commaop:</code></a>).
</p>
<script>
  tp(
    'f(actual\u2080,actual\u2081,actual\u2082);',
    [
      [
        [ 'f' ],
        '(',
        [
          [ 'actual\u2080' ],
          ',',
          [
            [ 'actual\u2081' ],
            ',',
            [ 'actual\u2082' ],
          ],
        ],
        ')',
      ],
      ';',
    ]
  );
</script>
<p>
  But semicolons (&lsquo;;&rsquo;) are postfix operators so there's
  no nesting in blocks, and in <code>for (init;cond;incr)</code>.
</p>
<script>
  tp(
    'for (init;cond;incr) {}',
    [
      [
        [ 'for' ],
        '(',
        [
          [ 'init' ],
          ';',
        ],
        [
          [ 'cond' ],
          ';',
        ],
        [ 'incr' ],
        ')',
      ],
      '{',
      '}',
    ]
  );
</script>

<p>
  In for loops, parts are optional.
  &ldquo;<code>for (;;) {}</code>&rdquo; has a postfix semicolon
  operator applied to a leaf &lsquo;<code>;</code>&rsquo; token which
  requires an extra branch in the for-loop rule.
</p>

<script>
  tp(
    'for (;;) {}',
    [
      [
        [ 'for' ],
        '(',
        [
          [ ';' ],  // Leaf token
          ';',
        ],
        ')'
      ],
      '{',
      '}'
    ]
  );
</script>

<p>Multiple adjacent NOPs behave the same.</p>
<script>
  tp(
    '{ ;;; }',
    [
      '{',
      [
        [ ';' ],
        ';',
      ],
      [
        ';',
      ],
      '}',
    ]
  );
</script>


<h2 id="parsing">Parsing</h2>

<p>
  Before defining the parser, we abstract out the set of operators.
  (This is just a wrapper for our <code>operators</code> array, but
  the abstraction will come in handy later when talking about
  user-defined operators a la Scala.)
</p>

<script class="visible">
const EMPTY_ARRAY = Object.freeze([]);
const EMPTY_SET = Object.freeze(new Set());

class OperatorSet {
  /** All operators, o, such that o.type===type&&o.tok===tokenText or null. */
  operators(type, tokenText) {
    throw new Error('pure abstract');
  }

  /**
   * A maximal set of outputs of this.operators(x, tokenText)
   * such that for each member, o, o.followers.indexOf(tokenText) >= 0.
   * Followers are used to handle ternary expressions: (cond ? this : that).
   */
  followedBy(tokenText) {
    throw new Error('pure abstract');
  }

  // TODO: whether something is an open bracket or a close
  // bracket should move here.
}

/** An operator set constructed from an array of operators. */
class ClosedOperatorSet extends OperatorSet {
  constructor(operators) {
    super();
    // Group entries to make it easy to find a relevant operator definition.
    this.typeToTokenToOperators = new Map();
    // Group followers for ternary ops.
    this.followerMap = new Map();

    for (const operator of operators) {
      const { tok, type, followers } = operator;
      let tokenToOperators = this.typeToTokenToOperators.get(type);
      if (!tokenToOperators) {
        this.typeToTokenToOperators.set(type, tokenToOperators = new Map());
      }
      let operatorArray = tokenToOperators.get(tok);
      if (!operatorArray) {
        tokenToOperators.set(tok, operatorArray = []);
      }
      operatorArray.push(operator);
      if (followers) {
        for (const follower of followers) {
          let ops = this.followerMap.get(follower);
          if (!ops) {
            this.followerMap.set(follower, ops = new Set());
          }
          ops.add(operator);
        }
      }
    }
  }

  operators(type, tokenText) {
    return this.typeToTokenToOperators.get(type).get(tokenText) || EMPTY_ARRAY;
  }

  followedBy(tokenText) {
    return this.followerMap.get(tokenText) || EMPTY_SET;
  }
}
</script>

<p>We can use the operator definitions and precedence relation to define a parser.</p>

<script class="visible">
function makeParser(opSet, canNest) {

  /**
   * Given a series of tokens with the structure produced by lex(),
   * returns a parse tree.
   *
   * For reference tokens have the following properties:
   *   tok:       the token text
   *   left:      index into the source whence came tok[0]
   *   right:     index into the source whence tok[tok.length-1] + 1
   *   synthetic: see recursive lexical structures
   *   mayInfix:  ditto
   *
   * A parse tree is a nested array structure where leaves are tokens.
   * In addition, each array has the following properties:
   *   op:    the operator
   *   left:  index into the source of the start of leftmost token contained
   *   right: index into the source of the end of rightmost token contained
   */
  return function parse(tokens) {
    if (typeof tokens === 'string' || !(Symbol.iterator in tokens)) {
      throw new TypeError('Expected iteratable over { tok, left, right }');
    }

    // We maintain a stack as we consume tokens left to right.
    // operatorStack[i+1] should be added as an operand to operatorStack[i]
    // unless an infix or postfix operator subsumes it.
    //
    // Each stack element has the following properties:
    //   op:          a member of the OperatorSet
    //   node:        the list of operands being built
    //   left, right: source position metadata
    const operatorStack = [{ op: rootOperator, node: [] }];

    /**
     * Truncate the stack by folding elements into their parents.
     * We do this lazily so that we can handle infix operations by
     * inserting them into the stack.
     *
     * After a call to commitTo(n) the length of the stack will be n.
     */
    function commitTo(depth) {
      let n = operatorStack.length;
      for (;n > depth; --n) {
        addNodeTo(operatorStack[n - 1], operatorStack[n - 2]);
      }
      operatorStack.length = n;
    }

    // Adds a node to a parent node
    function addNodeTo({ node, op, left, right }, parent) {
      // Store metadata with node.
      node.op = op;
      node.left = left;
      node.right = right;

      // Add the node to the parent.
      updatePositionMetadata(parent, left, right);
      parent.node.push(node);
    }

    // Adds a token to a node.
    function addTokenTo(token, el) {
      const { left, right } = token;
      el.node.push(token);
      updatePositionMetadata(el, left, right);
    }

    // Modify metadata to include code-units in the given range.
    function updatePositionMetadata(el, left, right) {
      el.left  = 'left' in el  ? Math.min(el.left,  left)  : left;
      el.right = 'right' in el ? Math.max(el.right, right) : right;
    }

    // We do some tricks to let us consume part of a token.
    // See angle bracket handling corner cases above:
    //     let a: Array<Array<number>>= [[]];
    let token = null;

    token_loop:
    for (let tokenIt = tokens[Symbol.iterator](), nextToken
         ;; token = nextToken) {
      nextToken = null;
      if (token === null) {
        let { value, done } = tokenIt.next();
        if (done) { break; }
        token = value;
      }
      // Now we've got a token.  Yay us!

      // The ordering in which we try strategies comes from a
      // preference to complete existing structures over
      // starting new structures.
      // This matters when a token might be interpretable as
      // *  both an infix operator or a ternary follower (':')
      // *  a prefix and postfix operator ('++', '--')
      // *  an infix operator and a aclose bracket ('>')
      // *  a postfix or nullary operator (';')

      const { tok, synthetic, mayInfix } = token;
      // See if tok might be part of a ternary or other operator.
      const follows = opSet.followedBy(tok);
      if (follows.size) {
        for (let i = operatorStack.length; --i >= 0;) {
          const el = operatorStack[i];
          if (needsCloseBracket(el)) {
            break;
          }
          const { op, node } = el;
          if (follows.has(op)) {
            let tokIndex = indexOfToken(node, op.tok);
            let maxFollowerSeen = -1;
            const fn = op.followers.length;
            // Figure out which followers we've consumed.
            for (let fi = 0; fi < fn; ++fi) {
              const follower = op.followers[fi];
              let ti = indexOfToken(node, follower, tokIndex + 1);
              if (ti >= 0) {
                maxFollowerSeen = fi;
                tokIndex = ti;
              }
            }
            // See if tok is a follower after the last consumed.
            const fip = op.followers.indexOf(tok, maxFollowerSeen + 1);
            if (fip >= 0) {
              commitTo(i + 1);
              addTokenTo(token, el);
              continue token_loop;
            }
          }
        }
      }

      // See if we can close an unclosed bracket operation.
      if (closeBrackets.has(tok) || tok[0] === '>') {
        const closeBracket = tok[0] === '>' ? '>' : tok;
        if (closeBrackets.has(closeBracket)) {
          for (let i = operatorStack.length; --i >= 0;) {
            const el = operatorStack[i];
            const partner = bracketPartners.get(el.op.tok);
            if (partner && closeBracket === partner && needsCloseBracket(el)) {
              // TODO: should probably also check that the open bracket
              // token's .synthetic === token.synthetic.
              commitTo(i + 1);
              let closeToken = token;
              if (tok !== closeBracket) {
                [ closeToken, nextToken ] =
                    splitToken(token, closeBracket.length);
                // Hack to let us find multiple close brackets in
                // tokens like ">>", ">>>", ">>=", ">>>=".
              }
              addTokenTo(closeToken, el);
              continue token_loop;
            }
          }
        }
      }

      // See if the token continues an existing stack element.
      // For infix and postfix operators, we're looking for a safe place to
      // insert in the middle of the stack.
      // (Yes, pedants, this means our stack isn't a stack.)
      //
      // We insert just below the bottommost stack element that could serve
      // as a left operand according to canNest.
      //
      // We take care not to break out of unclosed brackets.
      if (!synthetic || mayInfix) {
        // synthetic '(' should not participate in function calling.
        // See lexical preparsing to handle backquoted strings.
        for (const opType of [POSTFIX, INFIX]) {
          for (const op of opSet.operators(opType, tok)) {
            let leftDepth = null;
            const candidate = { op, node: [] };
            for (let i = operatorStack.length; --i >= 0;) {
              const el = operatorStack[i];
              // Don't swap an open bracket into something while we're
              // looking for the close bracket.
              if (needsCloseBracket(el)) { break; }
              // Can we swap el into a new binary operator as the
              // left argument.
              if (
                  // Can candidate contain el?
                  canNest(
                    (index) => index ? operatorStack[i - index] : candidate,
                    el)
                  // Can el's existing parent contain candidate?
                  && i
                  && canNest(
                    (index) => operatorStack[i - 1 - index],
                    candidate)) {
                leftDepth = i;
              }
            }
            if (leftDepth !== null) {
              const el = operatorStack[leftDepth];
              commitTo(leftDepth + 1);
              addNodeTo(el, candidate);
              addTokenTo(token, candidate);
              operatorStack[leftDepth] = candidate;
              continue token_loop;
            }
          }
        }
      }

      // See if the token indicates that we need a new stack element.
      // Any prefix operator starts a new stack element, but first we may
      // pop any operations that cannot contain that prefix operator.
      for (const op of opSet.operators(PREFIX, tok)) {
        const candidate = { op, node: [] };
        addTokenTo(token, candidate);
        // Commit stack elements that cannot contain candidate, so we
        // can start a new operand.
        for (let i = operatorStack.length; --i >= 0;) {
          const el = operatorStack[i];
          const { node, op: stackop } = el;
          if (stackop.type !== POSTFIX
              && canNest((index) => operatorStack[i - index], candidate)) {
            commitTo(i + 1);
            operatorStack.push(candidate);
            continue token_loop;
          }
          if (needsCloseBracket(el)) { break; }
        }
      }

      // No token left behind.
      // If no other strategy applied, treat the token as a parse tree leaf.
      const candidate = { op: notAnOperator, node: [] };
      addTokenTo(token, candidate);
      let closeTo = null;
      for (let i = operatorStack.length; --i >= 0;) {
        const el = operatorStack[i];
        if (el.op.type !== POSTFIX
            && canNest((index) => operatorStack[i - index], candidate)) {
          break;
        }
        closeTo = i;
      }
      if (closeTo !== null) {
        commitTo(closeTo);
      }

      let top = operatorStack[operatorStack.length - 1];
      // If we ever wanted to extend our precedence checks to
      // include a canTokenAppearIn(op, nonOperatorToken) or
      // canMergeInto(nonOperatorTokens, nonOperatorToken)
      // predicates, this is where they'd go.
      if (top.op === notAnOperator && !isNullary(top)) {
        addTokenTo(token, top);
      } else {
        operatorStack.push(candidate);
      }
    }

    // After processing all tokens, fold stack elements into their parents.
    commitTo(1);
    // Then attach metadata to the root and return it.
    let { node, left, right } = operatorStack[0];
    node.op = rootOperator;
    node.left = left;
    node.right = right;
    if (node.length === 1 && Array.isArray(node[0])) {
      // If the root is an unnecessary grouping abstraction, discard it.
      node = node[0];
    }
    return node;
  };
}

/**
 * Given a token and an offset into its token text, returns two adjacent tokens
 * whose token texts concatenate to token's token text.
 */
function splitToken(token, offset) {
  const splitPos = Math.min(token.left + offset, token.right);
  return [
    {
      ...token,
      tok: token.tok.substring(0, offset),
      right: splitPos,
    },
    {
      ...token,
      tok: token.tok.substring(offset),
      left: splitPos,
    },
  ].map(x => x.tok ? x : null);
}

/**
 * True iff x is a leaf parse tree node.
 * Leaf tree nodes are structurally the same as tokens.
 */
function isLeafNode(x) {
  return typeof x.tok === 'string';
}

/**
 * Given a list of nodes/tokens, finds the index of the leaf/token
 * with the wanted token text.
 */
function indexOfToken(nodeList, want /* : string */, startIndex = 0) {
  for (let i = startIndex, n = nodeList.length; i < n; ++i) {
    if (nodeList[i].tok === want) {
      return i;
    }
  }
  return -1;
}
</script>

<p>Tests use these unless otherwise specified.</p>

<script class="visible">
const operatorSet = new ClosedOperatorSet(operators);
const parse = makeParser(operatorSet, canNest);
</script>

<h2 id="lexing">Lexing</h2>

<p>We've defined a parser that operates on a stream of tokens, but
have not yet defined the source of those tokens.  This lexer is not
interesting except to demonstrate strategies for dealing with
irregularities and recursive lexical constructs without entangling the
parser &amp; lexer.</p>

<p>Note: Readers may find it confusing when I use the term
&ldquo;context-free&rdquo; (CF) to refer specifically to the lexical
grammar instead of the language as a whole.  Some C-like languages
have simple lexical grammars but are not CF.  E.g., in C++ the parser
needs context about whether &ldquo;x&rdquo; is a type to decide
whether <code>x* y;</code> is a declaration of a pointer variable or an
application of <code>operator *</code>.  This kind of complication
does not mean that an input cannot be split into tokens with a CF
lexical grammar, even though you may need to do some tricks when
&ldquo;<code>&gt;&gt;</code>&rdquo; follows type parameters.)  See
also
<a href="http://trevorjim.com/c-and-cplusplus-are-not-context-free/">Trevor Jim</a>.</p>

<p>C-like languages' lexical grammars need not be <i>regular</i>,
meaning there need not exist a single regular expression that
partitions the input into tokens.  JavaScript and Perl give some ideas
of where common non-regularities arise; neither have either regular or
context-free lexical grammars; both require scannerless parsing.</p>

<p id="scannerless">It is possible to restructure the parser above to be
scannerless; where the parser above asks &ldquo;is the current token
an infix operator?&rdquo;, a scannerless parser would ask &ldquo;which,
if any, is the longest infix operator that is a prefix of the remaining
input and can nest here?&rdquo;.</p>

<p>We do not do that though, because non-CF lexical grammars defeat our
goal of having simple analyses correctly segment fragments of code that
start and end on token boundaries.</p>

<p>So CF grammars meet our goals, but regular lexical grammars are
insufficient for commonly used, C-like languages.  Complications arise
when deciding whether &lsquo;/&rsquo; starts a division operator
(like <code>/</code> or <code>/=</code>) or a
<code>/regular-expression-literal/</code>.</p>

<p>Below is a lexer that recognizes
<code>/regular-expression-literals/</code> and
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">JavaScript-esque <code>`template ${ literals }`</code></a>.
It is CF but non-regular in two ways:</p>

<ul>
  <li>
    <p>When parsing a token starting with &lsquo;/&rsquo;</p>
    <ol>
      <li>If the token starts with <code>//</code> or <code>/*</code> then the
        current token is a comment token.</li>
      <li>Let <i>last</i> be the last significant (non-comment or whitespace) token.</li>
      <li>If <i>last</i> is a prefix operator, an infix operator, or an
        open bracket, then parse the current token as a regular expression.<br>
      <li>Else parse the current token as a division operator.</li>
    </ol>
    <p>This differs from JavaScript around expressions like <code>x = ++/regex/i.index</code>
      and <code>x++ /num/i</code> because some operators (++, --, +, -) are both infix/prefix
      and postfix operators.
      (The author believes this is not a source of confusion in practice,
      but has not measured).</p>
  </li>
  <li>The lexer keeps a stack of bits so it can tell whether a &lsquo;}&rsquo;
    is a regular source token or returns lexing to content of a JavaScript-esque
    template literal.</li>
</ul>

<script class="visible" id="lex-script">
// Identifiers and keywords start with a letter, underscore, dollar
// sign, non-ascii character, or unicode escape sequence.
const WORD_START = String.raw`(?:[_$a-zA-Z]|[^\x00-\x7F]|\\u[0-9a-fA-F]{4})`;
const WORD_CONTINUE = String.raw`(?:${ WORD_START }|[0-9])`;

const WORD_RE = new RegExp(`^${ WORD_START }${ WORD_CONTINUE }*$`);

/** A regex pattern that matches the input string literally. */
function regexEscape(x) {
  return x.replace(/[\W$]/g, '\\$&');
}

const allOperators = [...operators.map(x => x.tok), ...closeBrackets.keys()]
      .flat()
      // Keywords like `instanceof`, `else` handles as word tokens.
      .filter((x) => !WORD_RE.test(x))
      // Sort in reverse order so RegExp matches longest possible.
      .sort((a, b) => b.length - a.length);
const nonDivOperators = allOperators.filter((x) => x[0] !== '/');
const divOperators = allOperators.filter((x) => x[0] === '/');

// Matches ignorable tokens at start of input.
const ignorableTokens = new RegExp('^(?:' + [
  // White space.
  String.raw`[\t\n\r ]+`,
  // Line comment
  String.raw`//[^\n\r]*`,
  // Block comment
  String.raw`/[*](?:[^*]|[*]+(?![*/]))*(?:[*]/?)?`,
].join('|') + ')*');

// Matches a token whose interpretation does not depend on context.
const uncontroversialToken = new RegExp('^(?:' + [
  // Single quoted string
  String.raw`'(?:[^\n\r'\\]|\\(?:[^\n\r]|$))*'?`,
  // Double quoted string
  String.raw`"(?:[^\n\r"\\]|\\(?:[^\n\r]|$))*"?`,
  // Number
  String.raw`0[xX][0-9a-fA-F]+[g-zG-Z]*`,
  String.raw`[.][0-9]+(?:[eE][+\-]?[0-9]+)?[a-zA-Z]*`,
  String.raw`[0-9]+(?:[.][0-9]*)?(?:[eE][+\-]?[0-9]+)?[a-zA-Z]*`,
  // Non-division operator.
  ...nonDivOperators.map(regexEscape),
  // Identifier
  `@?${ WORD_START }${ WORD_CONTINUE }*`,
].join('|') + ')');

const divToken = new RegExp(
  '^(?:' + divOperators.map(regexEscape).join('|') + ')');

const regexpToken = new RegExp(
  (() => {
    const notAComment = String.raw`(?![*/])`;
    const normalChar = String.raw`[^\n\r/\[\\]`;
    const esc = String.raw`\\(?:[^\n\r]|$)`;
    const charBlock  = String.raw`\[(?:[^\\\]]|${ esc })*(?:\]|$)`;
    const bodyElement = String.raw`(?:${ normalChar }|${ esc }|${ charBlock })`;
    const closeAndFlags = String.raw`(?:/[a-zA-Z]*)?`;

    return String.raw`^/${ notAComment }${ bodyElement }*${ closeAndFlags }`;
    // If you ever have to debug this regex, please know that I am deeply sorry.
  })()
);

const backquoteStringContent = new RegExp(
  String.raw`^(?:[^\`\\$]|[$](?![\{])|\\[\s\S]?)*`);

/**
 * Given a source text, produce a series of tokens.
 *
 * Tokens have the form { tok, left, right } where left and right are
 * indices into sourceText, and tok is a substring of sourceText
 * (modulo ambiguity caveat below).
 *
 * The tokens may be broken, for example, an unclosed string literal.
 * If a broken token had to be adjusted to avoid ambiguity, for example,
 * a / at end of input where a regular expression literal is expected,
 * then onLexError will be called and an unambiguous token returned.
 *
 * Comment and whitespace tokens do not appear in the output unless
 * emitIgnorable is true.
 */
function *lex(
    sourceText,
  {
    opSet = operatorSet,
    onLexError = () => {},
    emitIgnorable = false,
  } = {}) {
  sourceText = `${ sourceText }`;

  // We need to keep track of whether, after a '}', comes more `...` content.
  const doesCloseCurlyReenterString = [];
  // One token of lookbehind used to disambiguate '/'.
  let lastToken = ';';
  // If in a backquoted string, any prefix for the content token.
  let backquotedStringPrefix = null;
  // The number of characters from the start of sourcePosition to the left
  // of sourceText.
  let sourcePosition = 0;

  // Consume n characters from sourceText.
  function consume(n) {
    sourceText = sourceText.substring(n);
    sourcePosition += n;
  }

  while (sourceText) {
    // Handle the case where a prefix of sourceText is part of a `...` string
    // that started earlier.
    if (backquotedStringPrefix !== null) {
      let left = sourcePosition - backquotedStringPrefix.length;
      let [ content ] = backquoteStringContent.exec(sourceText);
      consume(content.length);
      if (sourceText[0] === '`') {
        content += '`';
        consume(1);
      } else if (sourceText[0] === '$' && sourceText[1] === '{') {
        content += '${';
        consume(2);
        doesCloseCurlyReenterString.push(true);
      } else {
        // Need to differentiate unclosed token like `${ stuff }
        // from close curly token outside a backquote string.
        onLexError(left, sourcePosition, 'Unterminated string');
        content += '`';
      }
      lastToken = backquotedStringPrefix + content;
      yield ({
        tok: lastToken,
        left,
        right: sourcePosition,
        __proto__: null });
      backquotedStringPrefix = null;
      continue;
    }

    // Consume any comment or whitespace tokens.
    const [ { length: nToIgnore } ] = ignorableTokens.exec(sourceText);
    if (nToIgnore) {
      if (emitIgnorable) {
        yield({
          tok: sourceText.substring(0, nToIgnore),
          left: sourcePosition,
          right: sourcePosition + nToIgnore,
          __proto__: null,
        });
      }
      consume(nToIgnore);
      if (!sourceText) { break; }
    }

    // Handle '}' that reenters `...` content.
    const c = sourceText[0];
    if (c === '}') {
      const depth = doesCloseCurlyReenterString.length;
      if (depth && doesCloseCurlyReenterString[depth - 1]) {
        backquotedStringPrefix = '';
        --doesCloseCurlyReenterString.length;
        // Leave } as part of backquote string content so that it is
        // differntiable, solely based on text content, from non-backquote
        // string content tokens.
        // Every backquote string token either starts or ends with a backquote
        // or ends with "${" and starts with "}".
        continue;
      }
    }

    const left = sourcePosition;

    // Use lastToken to disambiguate between RegExp literals and div operators.
    if (c === '/') {
      const isRegexp = Boolean(
        lastToken === ';'
        || opSet.operators(PREFIX, lastToken).length
        || opSet.operators(INFIX, lastToken).length
        || opSet.followedBy(lastToken).size);
      let [ token ] = (
        isRegexp
          ? regexpToken
          : divToken ).exec(sourceText);
      consume(token.length);
      if (isRegexp && token === '/' || token === '/=') {
        onLexError(left, sourcePosition, 'Untermined RegExp literal');
        token += '(?:)';
      }
      yield ({
        tok: lastToken = token,
        left,
        right: sourcePosition,
        __proto__: null,
      });
      continue;
    }

    // Reenter if we're entering a `...` string literal.
    if (c === '`') {
      backquotedStringPrefix = '`';
      consume(1);
      continue;
    }

    // Use the bug regular expression defined above to find one token
    // at the front of input.
    const match = uncontroversialToken.exec(sourceText);
    let token;
    if (match) {
      ([ token ] = match);
    } else {
      // Consume one character as a fallback.
      // This handles characters like '#' that are not part of any
      token = c;
    }
    consume(token.length);
    // Keep the curly bracket stack up-to-date.
    if (/[{]$/.test(token)) {
      doesCloseCurlyReenterString.push(false);
    } else if (/^[}]/.test(token) && doesCloseCurlyReenterString.length) {
      --doesCloseCurlyReenterString.length;
    }
    yield ({
      tok: lastToken = token,
      left,
      right: sourcePosition,
      __proto__: null,
    });
  }

  // Error channel notified when input ends where we expect more content.
  if (backquotedStringPrefix !== null || doesCloseCurlyReenterString.length) {
    const message = backquotedStringPrefix !== null
          || doesCloseCurlyReenterString[doesCloseCurlyReenterString.length - 1]
          ? 'Source ended inside string'
          : 'Source ended inside brackets'
    onLexError(sourcePosition, sourcePosition, message);
  }
}
</script>

<p>Our lexer works as expected on some sample inputs.  These tests
show the series of tokens produced, with comment and whitespace
tokens filtered out.</p>

<script>
  tl(
    '{ foo(`a=${ a } b=${ b }`) }',
    [ '{', 'foo', '(', '`a=${', 'a', '} b=${', 'b', '}`', ')', '}']);
  tl(
    'a/b',
    [ 'a', '/', 'b']);
  tl(
    'a/b/i',
    [ 'a', '/', 'b', '/', 'i']);
  tl(
    'a=/b/i',
    [ 'a', '=', '/b/i']);
  tl(
    'a(/b/i)',
    [ 'a', '(', '/b/i', ')']);
  tl(
    'a/(b/i)',
    [ 'a', '/', '(', 'b', '/', 'i', ')']);
  tl(
    '/*a*//(b)/i/j/k',
    [ '/(b)/i', '/', 'j', '/', 'k']);
  tl(
    '/*a*//(b)/;/j/k',
    [ '/(b)/', ';', '/j/k']);
  tl(
    '/* only ignorable */ // tokens',
    []);
  tl(
    String.raw`[
      'strings', "strings", "more\t\"strings\"", "'", '"', "unterminated
    ]`,
    [
      '[',
      '\'strings\'', ',',
      '"strings"', ',',
      '"more\\t\\"strings\\""', ',',
      '"\'"', ',',
      '\'"\'', ',',
      '"unterminated',
      ']',
    ]);
  tl(
    '// line comment\nends',
    [ 'ends' ]);
  tl(
    '/* comments do not /* nest */ */',
    [
      '*',
      '/(?:)'  // A / where a RegExp is expected at end of input would be ambiguous.
    ],
    { hasLexErrors: true });
  tl(
    '/* numbers */ 0 .00001 123.456 1. 1e-1 6E23 1e+0 1L 4f 3.14159265e 1-1',
    [
      '0',
      '.00001',
      '123.456',
      '1.',
      '1e-1',
      '6E23',
      '1e+0',
      '1L',
      '4f',
      '3.14159265e',
      '1', '-', '1',
    ]
  );
</script>


<h3 id="token-preparsing">Token preparsing</h3>

<p>Unfortunately, our parser can't deal with complex constructs like
<code>`staticText ${ dynamicValue } etc.`</code> that span multiple
tokens.</p>

<script>
  tl('`staticText ${ dynamicValue } etc.`',
     ['`staticText ${', 'dynamicValue', '} etc.`']);
</script>

<p>We could build knowledge of this into the parser, but that would
defeat the goal of having few, simple rules, and moving most of the
understanding into the language-specific parse tree &rarr; AST
transform.</p>

<p>
  Instead, we transform the token stream between the lexer and the
  parser by adding synthetic tokens.  This keeps knowledge about
  complex lexical constructs in the pre-parse phases.
</p>

<table>
  <tr><th>Before</th><td> <td><code>`staticText ${</code></td>
    <td> <td><code>dynamicValue</code><td> <td><code>} etc.`</code><td> </tr>
  <tr><th>After </th><td>(<td><code>`staticText ${</code></td>
    <td>(<td><code>dynamicValue</code><td>)<td><code>} etc.`</code><td>)</tr>
</table>

<p>
  The added parentheses have the effect of ensuring that the whole
  string is grouped as one construct, and that expressions inside holes
  (<code>${...}</code>) are self-contained.  Open parenthesis is overloaded
  in most C-like languages to mean (grouping, function call, type cast)
  so we take care that the synthetized parentheses around holes
  are not interpreted as INFIX operations.
</p>

<script class="visible">
/**
 * Insert synthetic tokens into a token stream to ensure that recursive
 * lexial constructs are wrapped in parentheses to establish a separate
 * scope for precedence operations.
 */
function *preparseTokens(tokens) {
  for (const token of tokens) {
    const { tok } = token;
    const isBackquotedStringSection = /(?:.[$][{]|`)$/.test(tok);
    if (isBackquotedStringSection) {
      const startsStr = tok[0] === '`';
      yield {
        tok: (startsStr ? '(' : ')'),
        left: token.left,
        right: token.left,
        synthetic: true,
        // Synthetic parentheses around hole expressions should not
        // be interpreted as the parentheses around function call
        // arguments.
        mayInfix: startsStr,
      };
    }
    yield token;
    if (isBackquotedStringSection) {
      yield {
        tok: (tok[tok.length - 1] === '{' ? '(' : ')'),
        left: token.right,
        right: token.right,
        synthetic: true,
        mayInfix: false,
      };
    }
  }
}
</script>

<script id="template-literal-example">
  tl('`staticText ${ dynamicValue } etc.`',
     [ '(', '`staticText ${', '(', 'dynamicValue', ')', '} etc.`', ')' ],
     { preparse: preparseTokens });
</script>

<p>We can see that this parses sensibly, even when there's a
&lsquo;;&rsquo; in an expression that fills a hole, and that the
parentheses around holes do not participate in function
application.</p>

<script>
  tp(
    'f`__${ x; }__${ y = z() }__` + "str";',
    [
      [
        [
          [ 'f' ],
          '(',
          [ '`__${' ],
          [
            '(',  // Grouping, not function application.
            [
              [ 'x' ],
              // Semicolon does not drop out to statement context.
              ';'
            ],
            ')'
          ],
          [ '}__${' ],
          [
            '(',
            [
              [ 'y' ],
              // Low precedence assignment operator does not dop out of
              // higher precedence '+' operator.
              '=',
              [
                [ 'z' ],
                '(',
                ')'
              ],
            ],
            ')'
          ],
          [
            '}__`'
          ],
          ')'
        ],
        '+',
        [ '"str"' ]
      ],
      ';'
    ]
  );
</script>


<h2 id="asi">Automatic Semicolon Insertion (ASI)</h2>

<p>Some C-like languages automatically insert semicolons.</p>

<pre class="prettyprint">
let x = 1    /* ; */
let y = 2    // Not here
        + x  /* ; */
</pre>

<p>This may make writing code slightly easier, but in all these
languages is also a consistent source of confusion for authors.
Whether it is better for readers is unclear.</p>

<h3 id="syntactic-asi">Syntactic ASI</h3>
<p>ASI can be deeply entangled with parsing:</p>

<ul>
  <li><a href="https://tc39.es/ecma262/#sec-automatic-semicolon-insertion">JavaScript</a>'s
    ASI relies on exhaustive parsing to know when an insertion
    would not prevent expanding the current statement:
    <blockquote>
      <p>When, &hellip;, a token (called the offending token) is
        encountered that is not allowed by any production of the
        grammar, then a semicolon is automatically inserted before the
        offending token if &hellip;</p>
    </blockquote>
</ul>

<p>This operator precedence scheme allows two non-operator tokens to
appear adjacent: <code>int x</code>.  Any scheme to allow ASI in an
operator precedence grammar would need to explicitly handle this via
some kind of adjacency operator, so that the parser could elect to
insert a semicolon where nothing on the stack accepts the current
token.</p>

<h3 id="lexical-asi">Lexical ASI</h3>
<p>Alternatively, ASI can be based on lexical analysis before parsing
starts, which would allow it to be done during
<a href="#token-preparsing">token preparsing</a>:</p>

<ul>
  <li><a href="https://golang.org/ref/spec#Semicolons">Go</a>:
    <blockquote>
      <p>a semicolon is automatically inserted into the token stream
        immediately after a line's final token if that token is
        &hellip;</p>
    </blockquote>
  <li><a href="http://jittakal.blogspot.com/2012/07/scala-rules-of-semicolon-inference.html">Scala</a>:
    <blockquote>
      <p>A line ending is treated as a semicolon unless one of the
      following conditions is true: <i>[predicates about the top of
      the bracket stack, or next/last token]</i></p>
    </blockquote>
</ul>


<h2 id="custom-expression-operators">Custom Expression Operators</h2>

<p><a href="https://docs.scala-lang.org/tour/operators.html#precedence">Scala</a>
shows one way of providing for user-defined infix expression operators.</p>

<blockquote>
  <p>Any method with a single parameter can be used as an infix operator.</p>
  &hellip;
  <p>When an expression uses multiple operators, the operators are
  evaluated based on the priority of the first character: &hellip;</p>
</blockquote>

<p>It's unsurprising that operation precedence parsers can handle user defined
  operators with different precedences.</p>

<script>
  const scalaesqueOperatorSet = new class ScalaesqueOperatorSet extends OperatorSet {
    constructor(fallbackOperatorSet) {
      super();
      this.fallbackOperatorSet = fallbackOperatorSet;
      this.customOperatorTable = new Map();
    }

    operators(type, tokenText) {
      const builtin = this.fallbackOperatorSet.operators(type, tokenText);
      if (type === INFIX && !builtin.length) {
        let custom = this.customOperatorTable.get(tokenText) || null;
        if (!custom) {
          // Per scala docs (docs.scala-lang.org/tour/operators.html#precedence)
          // > When an expression uses multiple operators, the operators
          // > are evaluated based on the priority of the first character
          for (const withFirstChar
               of this.fallbackOperatorSet.operators(type, tokenText[0])) {
            if (!withFirstChar.closer) {
              custom = { ...withFirstChar, tok: tokenText };
              this.customOperatorTable.set(tokenText, custom);
              break;
            }
          }
        }
        return custom ? [custom] : EMPTY_ARRAY;
      }
      return builtin;
    }

    followedBy(tokenText) {
      return this.fallbackOperatorSet.followedBy(tokenText);
    }
  }(operatorSet);

  const scalaesqueParser = makeParser(scalaesqueOperatorSet, canNest);
</script>

<p>Now, if user code wanted to use <code>&lt;=&gt;</code> as a trinary comparison operator with
  precedence similar to <code>&lt;</code>, it can:</p>

<script>
  tp(
    'for (val a = 1; a + b <=> c * d +. e; ++a ) { doTheThing(a) }',
    [
      [
        [ "for" ],
        "(",
        [
          [
            [ "val", "a" ],
            "=",
            [ "1" ]
          ],
          ";",
        ],
        [
          [
            [
              [ "a" ],
              "+",
              [ "b" ]
            ],
            "<=>",
            [
              [
                [ "c" ],
                "*",
                [ "d" ]
              ],
              "+.",
              [ "e" ]
            ]
          ],
          ";",
        ],
        [
          "++",
          [ "a" ]
        ],
        ")"
      ],
      "{",
      [
        [ "doTheThing" ],
        "(",
        [ "a" ],
        ")"
      ],
      "}"
    ],
    {
      /**
       * A toy lexer that classifies each character as one of
       * (space, word, punctuation) and breaks into maximal
       * runs of each.  Does not handle comments or numbers
       * with fractions/signed exponents.
       */
      lexFn: function *splitOnBreaksAndSpaces(s) {
        const n = s.length;
        let lastCharType = ' ';
        let left = 0;
        for (let i = 0; i <= n; ++i) {
          const c = i < n ? s[i] : ' ';
          let charType = ' ';
          if (c > ' ') {
            charType = /\w/.test(c) ? 'a' : ';';
          }
          if (charType !== lastCharType) {
            if (lastCharType !== ' ') {
              yield { tok: s.substring(left, i), left, right: i };
            }
            left = i;
            lastCharType = charType;
          }
        }
      },
      parseFn: scalaesqueParser,
    });
</script>

<p>This requires some changed to lexing.  One downside is that custom operators require
developers to use more whitespace even in code that does not use custom operators.
This limitation arises because there is no closed set of punctuation strings that lets us
split, for example &ldquo;<code>x*-y</code>&rdquo; into &ldquo;<code>x * - y</code>&rdquo; because
&ldquo;<code>*-</code>&rdquo; could be a user defined operator.
C already has this problem to a small degree because &ldquo;<code>x--y</code>&rdquo;
is not the same as &ldquo;<code>x - -y</code>&rdquo;, but developers typically write
&ldquo;<code>x+y</code>&rdquo; instead of
subtracting a negated value, so the fact that &rdquo;<code>++</code>&ldquo; and
&rdquo;<code>--</code>&ldquo; are unsplittable by context-free lexers does not, in practice,
result in much confusion for C authors.</p>

<h2 id="well-formedness">Well-formedness</h2>

<p>It is a goal of this parsing style to represent partial and broken
inputs, so some passes may need to take some default action on inputs
that are not well-formed.  A parse-tree may be ill-formed in one of
several ways even if it structurally corresponds to an AST, so
throwing out malformed inputs can reduces the number of corner cases
that need to be considered by the parse tree &rarr; AST transform.</p>

<p>These tests show how a parse tree may fail some generic
well-formedness checks. Red
<span class="problem-tokens">wiggly</span> underlines show tokens that
participate in a malformed subtree.  Click the expando to see the
error messages.</p>

<ul>
  <li>A partial token like
    <script>
      twf(
        "s = 'no close quote",
        {
          parseTree: [ [ 's' ], '=', [ '\'no close quote' ] ],
          problems:  [ { left: 4, right: 19, message: 'Malformed token' } ],
        }
      );
      twf(
        '"ends with escape\\"',
        {
          parseTree: [ '"ends with escape\\"' ],
          problems:  [ { left: 0, right: 19, message: 'Malformed token' } ],
        }
      );
      twf(
        '"ends in escape\\',
        {
          parseTree: [ '"ends in escape\\' ],
          problems:  [ { left: 0, right: 16, message: 'Malformed token' } ],
        }
      );
      twf(
        '"invalid escape: \\x \\xA "',
        {
          parseTree: [ '"invalid escape: \\x \\xA "' ],
          problems:  [ { left: 0, right: 25, message: 'Malformed token' } ],
        }
      );
      twf(
        '/regex missing close',
        {
          parseTree: [ '/regex missing close' ],
          problems:  [ { left: 0, right: 20, message: 'Malformed token' } ],
        }
      );
      twf(
        '/* ambiguous partial regex */ /',
        {
          parseTree: [ '/(?:)' ],
          problems:  [
            { left: 30, right: 31, message: 'Untermined RegExp literal' },
            { left: 30, right: 31, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '/regex ends in [charblock',
        {
          parseTree: [ '/regex ends in [charblock' ],
          problems:  [
            { left: 0, right: 25, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '/* an unclosed comment',
        {
          parseTree: [],
          problems:  [
            { left: 0, right: 22, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '/* an unclosed comment *',
        {
          parseTree: [],
          problems:  [
            { left: 0, right: 24, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '`unclosed backquoted string',
        {
          parseTree: [ '(', [ '`unclosed backquoted string`' ], ')' ],
          problems:  [
            { left: 0, right: 27, message: 'Unterminated string' },
          ],
        }
      );
      twf(
        '`unclosed ${ hole',
        {
          parseTree: [
            '(',
            [ '`unclosed ${' ],
            [
              '(',
              [ 'hole' ],
            ],
          ],
          problems:  [
            { left: 17, right: 17, message: 'Source ended inside string' },
            { left: 0,  right: 17, message: 'Missing close bracket' },
            { left: 12, right: 17, message: 'Missing close bracket' },
          ],
        }
      );
    </script>
  </li>
  <li>
    An illegal token.
    <script>
      twf(
        '0129 // bad octal',
        {
          parseTree: [ '0129' ],
          problems:  [
            { left: 0, right: 4, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '0XabcdUL, 0XabcdWOT',
        {
          parseTree: [
            [ '0XabcdUL' ],
            ',',
            [ '0XabcdWOT' ],
          ],
          problems:  [
            { left: 10, right: 19, message: 'Malformed token' },
          ]
        }
      );
    </script>
  </li>
  <li>A missing token.
    <script>
      twf(
        'f( // no close parenthesis',
        {
          parseTree: [
            [ 'f' ],
            '(',
          ],
          problems:  [
            { left: 0, right: 2, message: 'Missing close bracket' },
          ],
        }
      );
      twf(
        'if (b) { blocks_balanced( } else { but_parens_not }',
        {
          parseTree: [
            [
              [
                [ 'if' ],
                '(',
                [ 'b' ],
                ')',
              ],
              '{',
              [
                [ 'blocks_balanced' ],
                '(',
              ],
              '}',
            ],
            'else',
            [
              '{',
              [ 'but_parens_not' ],
              '}',
            ]
          ],
          problems: [
            { left: 9, right: 25, message: 'Missing close bracket' },
          ]
        }
      );
      twf(
        '{ statement; // missing close brace',
        {
          parseTree: [
            '{',
            [
              [ 'statement' ],
              ';'
            ],
          ],
          problems:  [
            { left: 35, right: 35, message: 'Source ended inside brackets' },
            { left: 0,  right: 12, message: 'Missing close bracket' },
          ],
        }
      );
      twf(
        'if (/* missing left operand */ || x) {}',
        {
          parseTree: [
            [
              [ 'if' ],
              '(',
              [
                '||',
                'x'
              ],
              ')',
            ],
            '{',
            '}',
          ],
          problems:  [
            { left: 31, right: 35 /* or 33 */, message: 'Operator || missing left argument' },
          ],
        }
      );
    </script>
  </li>
  <li>A missing construct.
    <script>
      twf(
        'do {} while',
        {
          parseTree: [
            [
              'do',
              [
                '{',
                '}',
              ],
            ],
            'while',
          ],
          problems:  [
            { left: 0, right: 11, message: 'Missing operand' },
          ],
        }
      );
      twf(
        '++ /* no operand */;',
        {
          parseTree: [
            [
              '++',
            ],
            ';',
          ],
          problems:  [
            { left: 0, right: 2, message: 'Missing operand' },
          ],
        }
      );
      twf(
        'x. + ;',
        {
          parseTree: [
            [
              [
                ['x'],
                '.',
              ],
              '+',
            ],
            ';',
          ],
          problems:  [
            { left: 0, right: 4, message: 'Missing operand' },
            { left: 0, right: 2, message: 'Missing operand' },
          ],
        }
      );
      twf(
        'x = ternary ? option0;',
        {
          parseTree: [
            [
              [ 'x' ],
              '=',
              [
                [ 'ternary' ],
                '?',
                [ 'option0' ],
              ],
            ],
            ';',
          ],
          problems:  [
            { left: 4, right: 21, message: 'Expected \':\'' },
          ],
        }
      );
      twf(
        'x = ternary ? option0 :;',
        {
          parseTree: [
            [
              [ 'x' ],
              '=',
              [
                [ 'ternary' ],
                '?',
                [ 'option0' ],
                ':',
              ],
            ],
            ';',
          ],
          problems:  [
            { left: 4, right: 23, message: 'Expected operand after \':\'' },
          ],
        }
      );
      twf(
        'statement_label: /* no statement */',
        {
          parseTree: [
            [ 'statement_label' ],
            ':',
          ],
          problems:  [
            { left: 0, right: 16, message: 'Missing operand' },
          ],
        }
      );
    </script>
  </li>
  <li>Extra tokens
    <script>
      twf(
        '{ } }',
        {
          parseTree: [
            [ '{', '}' ],
            [ '}' ],
          ],
          problems:  [
            { left: 4, right: 5, message: 'Unmatched close bracket' },
          ],
        }
      );
    </script>
  </li>
  <li>Things that aren't recognized as errors but could be
    <script>
      twf(
        '`empty hole ${ }`',
        {
          parseTree: [
            '(',
            [ '`empty hole ${' ],
            [
              '(',
              ')',
            ],
            [ '}`' ],
            ')',
          ],
          problems:  [],
        }
      );
      twf(
        'while (cond) // missing block',
        {
          parseTree: [
            [ 'while' ],
            '(',
            [ 'cond' ],
            ')',
          ],
          problems:  [],
        }
      );
      twf(
        'while /* no condition */ {}',
        {
          parseTree: [
            [ 'while' ],
            '{',
            '}',
          ],
          problems:  [],
        }
      );
      twf(
        'array[/* no index */]',
        {
          parseTree: [
            [ 'array' ],
            '[',
            ']',
          ],
          problems:  [],
        }
      );
    </script>
  </li>
</ul>

<script class="visible">
/**
 * True if input is a well-formed token.
 *
 * This is advisory.  The definition of well-formedness is likely
 * more language specific than the overly-inclusive parser and lexer
 * defined above.
 *
 * This is sufficient for the output from lex, but not for
 * programattically generated tokens.  For example, it does not check
 * that line comments do not have embedded newlines or that block
 * comments do not embed "*\/".
 */
function isWellformedToken(tok) {
  // Require NFC for identifiers.
  if (WORD_RE.test(tok)) {
    const decoded = tok.replace(
      /\u([0-9A-Fa-f])/g,
      (_, hex) => String.fromCharCode(parseInt(hex, 16)));
    if (decoded !== decoded.normalize('NFC')) {
      return false;
    }
  }
  return wellformedTokenPattern.test(tok);
}

function checkParseTree(parseTree, { opSet = operatorSet } = {}) {
  const problems = [];
  walk(parseTree);
  return problems;

  function walk(pt) {
    const { op, left, right } = pt;
    if (!op) {
      problems.push({ left, right, message: 'Missing op metadata' });
    }

    switch (op.type) {
    case INFIX:
      if (op.closer && openBracketCount({ node: pt, op }, -1) !== 0) {
        problems.push({ left, right, message: 'Missing close bracket' });
      } else if (pt.length < 3 && (op.tok !== ';' && op.tok !== ',')) {
        problems.push({ left, right, message: 'Missing operand' });
      }
      if (op.followers) {
        let followerIndex = 0;
        for (let i = 2, n = pt.length; i < n; ++i) {
          const follower = op.followers[followerIndex];
          if (isLeafNode(pt[i]) && pt[i].tok === follower) {
            ++followerIndex;
            if (i + 1 === n || isLeafNode(pt[i + 1])) {
              const message = `Expected operand after '${ follower }'`;
              problems.push({ left, right, message });
              followerIndex = op.followers.length;
              break;
            }
          }
        }
        if (followerIndex < op.followers.length) {
          problems.push({
            left,
            right,
            message: `Expected '${ op.followers[followerIndex] }'`
          });
        }
      }
      break;
    case PREFIX:
      if (op.closer && openBracketCount({ node: pt, op }, -1) !== 0) {
        problems.push({ left, right, message: 'Missing close bracket' });
      }
      if (pt.length === 1 && op.tok !== 'default' && op.tok !== 'return') {
        problems.push({ left, right, message: 'Missing operand' });
      }
      break;
    case POSTFIX:
      if (pt.length === 1) {
        problems.push({ left, right, message: 'Missing operand' });
      }
      break;
    case TOKEN:
      for (const { tok: el } of pt) {
        if (opSet.operators(INFIX, el).length
            || opSet.operators(POSTFIX, el).length) {
          if (!opSet.operators(PREFIX, el).length
              && el !== 'while' && el !== ';') {
            const message = `Operator ${ el } missing left argument`;
            problems.push({ left, right, message });
          }
        } else if (closeBrackets.has(el)) {
          problems.push({ left, right, message: `Unmatched close bracket` });
        }
      }
      break;
    default:
      problems.push({ left, right, message: `Unrecognized type ${ op.type }` });
      break;
    }

    for (const el of pt) {
      if (isLeafNode(el)) {
        if (!isWellformedToken(el.tok)) {
          problems.push({ left, right, message: 'Malformed token' });
        }
      } else {
        walk(el);
      }
    }
  }
}

const wellformedTokenPattern = new RegExp('^(?:' + [
  // Strings
  String.raw`'(?:[^'\\]|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\['"\`\\btrnf])*'`,
  String.raw`"(?:[^"\\]|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\['"\`\\btrnf])*"`,
  String.raw`[\`\}](?:[^\`\\$]|\\[\s\S]|[$](?!\{))*(?:\`|[$]\{)`,
  // Numbers
  String.raw`(?:[1-9.]|0[.])[0-9.+\-]*[FfIiLlUu]*`,  // TODO: overmatches
  String.raw`0[Xx][0-9A-Fa-f]+[IiLlUu]*`,
  String.raw`0[0-7]*[IiLlUu]*`,
  // Identifiers
  (   String.raw`(?:[_$a-zA-Z]|\\u[0-9A-Fa-f]{4}|[^\x00-\xFF])` +
   String.raw`(?:[_$0-9a-zA-Z]|\\u[0-9A-Fa-f]{4}|[^\x00-\xFF])*`),
  // Punctuation
  String.raw`[^\w\s/]+`,
  // Regex or div
  // TODO: does not check well-formedness of regexs.  E.g. /(/, /.{1/
  String.raw`(?:/(?![*/])`  // RegExp start and precondition
    + String.raw`(?:[^/\\\[]|\\[^\r\n]|\[(?:[^\\\]]|\\.)*\])+` // RegExp content
    + String.raw`/[gim]*`   // RegExp Flags
    + String.raw`|/=?)`,    // Division operator
  // Comments and whitespace
  (
    '(?:' + [
      String.raw`[\t\n\r ]+`,
      String.raw`//[^\n\r]*`,
      String.raw`/[*](?:[^*]|[*](?!/))*[*]/`,
    ].join('|') + ')+'
  ),
].join('|') + ')$');
</script>

<h2 id="combinators">Deriving ASTs via Combinators</h2>
<p>
  Many tools properly operate on parse trees, but some, chiefly
  compilers and interpreters, do better with representations that lack
  extraneous details, and are more directly related to language
  specification abstractions or elements of the output.
  &ldquo;Compilers: Principles, Techniques, and Tools&rdquo; by
  Aho, Sethi, Ullman contrasts parse trees with a more abstract tree
  representation:
</p>

<blockquote>
  Abstract syntax trees, or simply syntax trees, differ from parse
  trees because superficial distinctions of form, unimportant for
  translation, do not appear in syntax trees.
</blockquote>

<p>
  Parser combinators are a fine way to turn a source text into a
  parse tree, but they can also be used to derive an abstract syntax
  tree (AST) from a parse tree.
</p>

<p>
  These tests show ASTs.  Each inner AST node has a green border, and
  the node type in small, green print overlapping the top-left of its
  border.  Leaf nodes are black text, have no type, and always
  correspond to tokens in the input.
</p>

<script>
  ta(
    'x = a + b * c;',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "expr",
            "children": [
              {
                "type": "infix",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "id",
                        "children": [
                          "x"
                        ]
                      }
                    ]
                  },
                  "=",
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "infix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "a"
                                ]
                              }
                            ]
                          },
                          "+",
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "infix",
                                "children": [
                                  {
                                    "type": "expr",
                                    "children": [
                                      {
                                        "type": "id",
                                        "children": [
                                          "b"
                                        ]
                                      }
                                    ]
                                  },
                                  "*",
                                  {
                                    "type": "expr",
                                    "children": [
                                      {
                                        "type": "id",
                                        "children": [
                                          "c"
                                        ]
                                      }
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
  ta(
    '{ foo(1); bar(); baz(x,++y); }',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "block",
            "children": [
              {
                "type": "expr",
                "children": [
                  {
                    "type": "call",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "id",
                            "children": [
                              "foo"
                            ]
                          }
                        ]
                      },
                      {
                        "type": "actuals",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "literal",
                                "children": [
                                  "1"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "expr",
                "children": [
                  {
                    "type": "call",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "id",
                            "children": [
                              "bar"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "expr",
                "children": [
                  {
                    "type": "call",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "id",
                            "children": [
                              "baz"
                            ]
                          }
                        ]
                      },
                      {
                        "type": "actuals",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "prefix",
                                "children": [
                                  "++",
                                  {
                                    "type": "expr",
                                    "children": [
                                      {
                                        "type": "id",
                                        "children": [
                                          "y"
                                        ]
                                      }
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
  ta(
    '{ let x = 0; while(bar()) { ++x; } return x; }',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "block",
            "children": [
              {
                "type": "decl",
                "children": [
                  {
                    "type": "let",
                    "children": [
                      {
                        "type": "id",
                        "children": [
                          "x"
                        ]
                      },
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "literal",
                            "children": [
                              "0"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "while",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "call",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "bar"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "type": "block",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "prefix",
                            "children": [
                              "++",
                              {
                                "type": "expr",
                                "children": [
                                  {
                                    "type": "id",
                                    "children": [
                                      "x"
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "return",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "id",
                        "children": [
                          "x"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
  ta(
    'if (a) { x++; } else if (b) { y++; } else { z++; }',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "if",
            "children": [
              {
                "type": "expr",
                "children": [
                  {
                    "type": "id",
                    "children": [
                      "a"
                    ]
                  }
                ]
              },
              {
                "type": "block",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "postfix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          "++"
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "else",
                "children": [
                  {
                    "type": "if",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "id",
                            "children": [
                              "b"
                            ]
                          }
                        ]
                      },
                      {
                        "type": "block",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "postfix",
                                "children": [
                                  {
                                    "type": "expr",
                                    "children": [
                                      {
                                        "type": "id",
                                        "children": [
                                          "y"
                                        ]
                                      }
                                    ]
                                  },
                                  "++"
                                ]
                              }
                            ]
                          }
                        ]
                      },
                      {
                        "type": "else",
                        "children": [
                          {
                            "type": "block",
                            "children": [
                              {
                                "type": "expr",
                                "children": [
                                  {
                                    "type": "postfix",
                                    "children": [
                                      {
                                        "type": "expr",
                                        "children": [
                                          {
                                            "type": "id",
                                            "children": [
                                              "z"
                                            ]
                                          }
                                        ]
                                      },
                                      "++"
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
  ta(
    'for (x = 0; x < 0; x++) { f(x); }',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "for",
            "children": [
              {
                "type": "forinit",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "infix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          "=",
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "literal",
                                "children": [
                                  "0"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "forcond",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "infix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          "<",
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "literal",
                                "children": [
                                  "0"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "forincr",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "postfix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          "++"
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "block",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "call",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "f"
                                ]
                              }
                            ]
                          },
                          {
                            "type": "actuals",
                            "children": [
                              {
                                "type": "expr",
                                "children": [
                                  {
                                    "type": "id",
                                    "children": [
                                      "x"
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
</script>

<p>And this doesn't prevent containing errors:</p>

<script>
  ta(
    'do { problem /* MISSING SEMICOLON */ } while (cond);',
    [
      {
        type: 'program',
        children: [
          {
            type: 'do',
            children: [
              {
                type: 'block',
                children: [{ type: 'ERROR', discards: ['problem'] }]
              },
              {
                type: 'expr',
                children: [{ type: 'id', children: ['cond'] }]
              }
            ]
          }
        ]
      }
    ],
  );

  ta(
    'x += (y * ) + 3;',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "expr",
            "children": [
              {
                "type": "infix",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "id",
                        "children": [
                          "x"
                        ]
                      }
                    ]
                  },
                  "+=",
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "infix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "ERROR",
                                "discards": [
                                  "IN",
                                  "IN",
                                  "y",
                                  "DE",
                                  "*",
                                  "DE"
                                ]
                              }
                            ]
                          },
                          "+",
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "literal",
                                "children": [
                                  "3"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );

  ta(
    'function f(x) { return x + ; }',
    [
      {
        type: 'program',
        children: [
          {
            type: 'decl',
            children: [
              {
                type: 'function',
                children: [
                  'f',
                  {
                    type: 'formals',
                    children: [
                      {
                        type: 'formal',
                        children: [{ type: 'id', children: ['x'] }]
                      }
                    ]
                  },
                  {
                    type: 'block',
                    children: [
                      {
                        type: 'ERROR',
                        discards: [
                          'IN', 'return', 'IN', 'IN', 'x',
                          'DE', '+', 'DE', 'DE', ';'
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );

  ta(
    'f(x, y +, z);',
    [
      {
        type: 'program',
        children: [
          {
            type: 'expr',
            children: [
              {
                type: 'call',
                children: [
                  {
                    type: 'expr',
                    children: [{ type: 'id', children: ['f'] }]
                  },
                  {
                    type: 'actuals',
                    children: [
                      {
                        type: 'expr',
                        children: [{ type: 'id', children: ['x'] }]
                      },
                      {
                        type: 'ERROR',
                        discards: [
                          'IN',
                          'IN',
                          'y',
                          'DE',
                          '+',
                          'DE'
                        ]
                      },
                      {
                        type: 'expr',
                        children: [{ type: 'id', children: ['z'] }]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );

  ta(
    '{ do; f(); }',
    [
      {
        type: 'program',
        children: [
          {
            type: 'block',
            children: [
              {
                type: 'ERROR',
                discards: ['IN', 'do', 'DE', ';'],
              },
              {
                type: 'expr',
                children: [
                  {
                    type: 'call',
                    children: [
                      {
                        type: 'expr',
                        children: [{ type: 'id', children: ['f'] }]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
</script>

<p>Combinators operate on a sequence of tokens, so, first, we need to
transform our parse tree into a sequence.</p>

<table id="flattening-example-table">
  <caption>Flattening a parse tree</caption>
  <tr><th>Input<td style="font-family: Lucida">&ldquo;<td><td class="kwd">let<td><td>x<td><td class="pun">=<td><td class="lit">1<td><td class="pun">;<td style="font-family: Lucida">&rdquo;</tr>
  <tr><th>Tokens<td><td><td class="str">"let"<td><td class="str">"x"<td><td class="str">"="<td><td class="str">"1"<td><td class="str">";"<td></tr>
  <tr><th>Parse Tree<td class="pun">[<td class="pun">[<td class="str">"let"<td class="pun">,<td class="str">"x"<td class="pun">],<td class="str">"="<td class="pun">, [<td class="str">"1"<td class="pun">],<td class="str">";"<td class="pun">]</tr>
  <tr><th>Flat Tree<td>&#x21e8;<td>&#x21e8;<td class="str">"let"<td><td class="str">"x"<td>&#x21e6;<td class="str">"="<td>&#x21e8;<td class="str">"1"<td>&#x21e6;<td class="str">";"<td>&#x21e6;</tr>
</table>

<p>As you can see, a flattened parse tree:</p>
<ul>
  <li>is a series of tokens and pseudo-tokens.</li>
  <li>uses a single kind of bracket (&#x21e8;&hellip;&#x21e6; above).</li>
  <li>is always balanced even for malformed parse trees.</li>
  <li>is consumable by parser combinators.</li>
</ul>

<p>The flatten function takes a parse tree and produces a sequence
with indent and dedent psuedo-tokens around the content of each inner
node.</p>

<script class="visible">
const PSEUDO_TOK_INDENT = {   // Pseudo-token that marks start of inner node
  toString() { return '\u21e8' },
  toJSON() { return 'IN'; }
};
const PSEUDO_TOK_DEDENT = {   // Pseudo-token that marks end of inner node
  toString() { return '\u21e6' },
  toJSON() { return 'DE'; }
};

/** Turns a parse tree into a series of s-expr like tokens. */
function flattenParseTreeToPseudoTokens(parseTree) {
  const out = [];
  if (parseTree.op === rootOperator) {
    for (const toplevel of parseTree) {
      walk(toplevel);
    }
  } else {
    walk(parseTree);
  }
  return out;

  function walk(parseTree) {
    if (isLeafNode(parseTree)) {
      out.push(parseTree);
    } else if (Array.isArray(parseTree)) {
      out.push(PSEUDO_TOK_INDENT);
      for (const child of parseTree) {
        walk(child);
      }
      out.push(PSEUDO_TOK_DEDENT);
    } else {
      throw new Error(parseTree);
    }
  }
}
</script>

<p>
  Because the flattened tree contains explicit &#x21e8; and &#x21e6;
  it can be consumed by simple combinators that make no special
  provisions for either Left- or Right- recursion.  Readers familiar
  with widely used combinator libraries will probably find the
  implementation uninteresting; you can skip them without missing
  anything.
</p>

<p>Here are the combinator definitions, but </p>

<details>
  <summary>Definitions of combinators</summary>
<script class="visible">
const combinators = (() => {
  // A combinator is a function(context, position)
  // where context has the form {
  //   input,    // a list of "tokens" to process
  //   output,   // which combinators may append to if they succeed
  //   grammar,  // used to lookup productions
  // },
  // and position is an index into context.input.
  // A combinator returns null to indicate match failure,
  // or otherwise the position after application which must
  // be >= the input position.

  /** A grammar maps names to positions. */
  class Grammar {
    constructor(declarations = {}) {
      this.productions = new Map();
      for (const name of Object.getOwnPropertyNames(declarations)) {
        this.declare(name, declarations[name]);
      }
    }
    declare(name, body) {
      if (this.productions.has(name)) {
        throw new Error(`duplicate ${ name }`);
      }
      this.productions.set(name, toCombinator(body));
    }
    /**
     * Applies the named production to the input.
     * Returns null or {output, position} where
     * position is after parse.
     * To fail when not all input is matched, use
     * the EOF combinator.
     */
    apply(name, input) {
      const context = {
        grammar: this,
        input: [...input],
        output: [],
      };

      const after = Ref(name)(context, 0);
      return typeof after === 'number'
        ? { ast: lift(context.output), position: after }
        : null;
    }
    getProduction(name) {
      return this.productions.get(name);
    }
    productionNames() {
      return this.productions.keys();
    }
  }

  // Here are some outputs that allow building an AST.
  class EnterEvent {  // Starts an AST node
    constructor(name) { this.name = name; }
    toString() { return `(Enter ${ this.name })`; }
    toJSON() { return this.toString(); }
  }
  class ExitEvent {  // Ends an AST node
    constructor(name) { this.name = name; }
    toString() { return `(Exit ${ this.name })`; }
    toJSON() { return this.toString(); }
  }
  class ErrorEvent {  // Indicates that problem tokens were discarded
    constructor(discards) { this.discards = discards; }
    toString() { return 'ERROR'; }
    toJSON() {
      return { type: 'ERROR', discards: this.discards };
    }
  }

  /** "Lifting" is turning a series of AST pseudo-tokens into an AST. */
  function lift(astPseudoTokens) {
    const n = astPseudoTokens.length;
    function liftSome(pos, items) {
      for (let i = pos; i < n; ++i) {
        const pt = astPseudoTokens[i];
        if (pt instanceof ExitEvent) {
          return i;
        } else if (pt instanceof EnterEvent) {
          const t = {
            type: pt.name,
            children: [],
          };
          i = liftSome(i + 1, t.children);
          if (i < n && astPseudoTokens[i] instanceof ExitEvent) {
            // ++i above will consume
            items.push(t);
          } else {
            throw new Error(`unbalanced at ${ i }`);
          }
        } else {
          items.push(pt);
        }
      }
      return n;
    }
    const forest = [];
    liftSome(0, forest);
    return forest;
  }

  const EPSILON = Cat();

  // Implicit coercion for combinators
  function toCombinator(x) {
    if (typeof x === 'function') {
      return x;
    } else if (typeof x === 'string') {
      const match = /^<([a-z]+)(_opt)?([.])?>$/.exec(x);
      if (match) {
        const ref = Ref(match[1], !match[3]);
        return match[2] ? Or(ref, EPSILON) : ref;
      }
      return Match(x, false);
    } else if (Array.isArray(x)) {
      return Cat(...x);
    } else if (typeof x.test === 'function') {
      return Match(x, true);
    } else {
      console.error('toCombinator(%o)', x);
      throw new Error(x);
    }
  }

  /** A reference to a production. */
  function Ref(name, nests = true) {
    return (context, position) => {
      const outputLengthAtStart = context.output.length;
      if (nests) { context.output.push(new EnterEvent(name)); }
      // Optimistically assume no LR.  We don't need LR
      // since the operator precedence parser parenthesizes for us.
      const rhs = context.grammar.getProduction(name);
      if (!rhs) {
        throw new Error(`No definition for production ${ name }`);
      }
      const afterSeed = rhs(context, position);
      if (typeof afterSeed !== 'number') {
        context.output.length = outputLengthAtStart;
        return null;
      }
      if (nests) { context.output.push(new ExitEvent(name)); }
      return afterSeed;
    };
  }

  /** Concatenation. */
  function Cat(...parts) {
    parts = parts.map(toCombinator);
    return (context, position) => {
      const outputLengthAtStart = context.output.length;
      let after = position;
      for (const part of parts) {
        after = part(context, after);
        if (typeof after !== 'number') {
          context.output.length = outputLengthAtStart;
          return null;
        }
      }
      return after;
    };
  }
  /** Alternation. */
  function Or(...options) {
    options = options.map(toCombinator);
    return (context, position) => {
      for (const option of options) {
        let after = option(context, position);
        if (typeof after === 'number') {
          return after;
        }
      }
      return null;
    };
  }
  /**
   * Matches an input token.
   * If emit is truthy, matched content is copied to the output.
   */
  function Match(pattern, emit) {
    return ({ input, output }, position) => {
      if (input.length > position) {
        let target = input[position];
        if (isLeafNode(target)) {
          target = target.tok;
        }
        const matched = pattern instanceof RegExp
              ? typeof target === 'string' && pattern.test(target)
              : pattern === target;
        if (matched) {
          if (emit) { output.push(target); }
          return position + 1;
        }
      }
      return null;
    };
  }

  return {
    PSEUDO_TOK_INDENT,
    PSEUDO_TOK_DEDENT,
    Grammar,
    // Combinator constructors.
    Ref,
    /** Kleene plus style repetition. */
    Rep(body) {
      body = toCombinator(body);
      return (context, position) => {
        let before = position;
        let after = body(context, before);
        if (typeof after !== 'number') {
          return null;
        }
        while (typeof after === 'number' && after > before) {
          before = after;
          after = body(context, before);
        }
        return before;
      };
    },
    Cat,
    Or,
    Opt(...bodies) { return Or(...bodies, EPSILON); },
    Want(x) { return Match(x, false); },
    Echo(x) { return Match(x, true); },
    NegLA(body) {
      body = toCombinator(body);
      return (context, position) => {
        const outputLengthAtStart = context.output.length;
        if ('number' === typeof body(context, position)) {
          context.output.length = outputLengthAtStart;
          return null;
        } else {
          return position;
        }
      };
    },
    Garbage({ stopBefore = closeBrackets, stopAfter = [], requireSome } = {}) {
      stopBefore = new Set(stopBefore);
      stopAfter = new Set(stopAfter);

      return ({ input, output }, position) => {
        let nIndent = 0;
        let after;
        for (after = position; after < input.length; ++after) {
          const inp = input[after];
          if (inp === PSEUDO_TOK_INDENT) {
            ++nIndent;
          } else if (inp === PSEUDO_TOK_DEDENT) {
            if (nIndent === 0) { break; }
            --nIndent;
          } else if (isLeafNode(inp) && nIndent === 0) {
            if (stopAfter && stopAfter.has(inp.tok)) {
              ++after;
              break;
            }
            if (stopBefore.has(inp.tok)) {
              break;
            }
          }
        }
        if (after > position) {
          output.push(new ErrorEvent(input.slice(position, after)));
          return after;
        }
        return requireSome ? null : after;
      };
    },
    Debug(description, body) {
      body = toCombinator(body);
      return (context, position) => {
        let { input } = context;
        console.group(`${ description } @ ${ position } : ${
            position < input.length ? input[position].tok : 'none'
        }`);
        let result;
        try {
          result = body(context, position);
          if (result !== null) {
            console.log(`Application succeeded -> ${ result }`);
          } else {
            console.log('Application failed');
          }
        } finally {
          console.groupEnd();
        }
        return result;
      };
    },
    // Singletons
    EPSILON,
    EOF({ input }, position) {
      return (input.length === position) ? position : null;
    },
    // The indent and dedent tokens mark the start and end of parse tree nodes
    // in the pseudo-token list formed from a flattened parse tree that is fed
    // to combinators/grammars.
    IN: Match(PSEUDO_TOK_INDENT, false),
    DE: Match(PSEUDO_TOK_DEDENT, false),
    // Output event classes
    EnterEvent,
    ExitEvent,
  };
})();
</script>
</details>

<p>
  Here is a grammar for a toy language that looks like TypeScript.
  This grammar has gaps (no <code>switch</code>); it is too long already.
</p>

<script class="visible" id="toy-grammar">
function makeToyLanguageGrammar({
  // Combinators and constructors for combinators defined later.
  Grammar, /*Con*/Cat/*enate*/, NegLA, Opt/*ional*/, Or, Ref/*erence*/,
  Rep/*etition*/, Want /*consumes*/, Garbage /*eats bad tokens*/, EOF,
  IN/*DENT*/, DE/*DENT*/, Debug,
}) {
  // Matches identifiers.
  const idPattern = new RegExp(
    String.raw`^(?!(?:${
      // Reserved keywords
      'break|continue|do|else|for|function|if|let|new|return|throw|while'
    })$)@?${ WORD_START }${ WORD_CONTINUE }*$`);
  const litPattern = /^(?:[.]?\d|[\'\"]|\/.*\/[gim]*$)/;

  return {
    // This object constructor relates property names to combinators.

    // Nonterminals are in angle brackets, so
    //   '<foo>'
    // is a reference to the combinator to the right of
    //   foo:
    // and if that combinator succeeds, the output gets an AST node
    // with {type:'foo'}.

    // '<foo.>' is a "silent" reference.  The output will not have an AST
    // node with {type:'foo'}.  Instead, the children that would be in
    // that node will be inlined in its would-be parent.

    // '<foo_opt>' is an optional reference; it is shorthand for
    // Opt('<foo>').


    // Programs match when it can eat <toplevels> and doing so
    // processes the entire input (reaches end-of-file).
    program: ['<toplevels.>', EOF],
    toplevels: Opt(Rep('<toplevel.>')),
    toplevel: Or(
      '<decl>',
      '<stmt.>',
      // We try to recover from errors if the input doesn't contain
      // a declaration or a statement.
      [IN, Garbage({ stopAfter: [';'], stopBefore: ['}'] }), DE],
      Garbage(),
    ),

    stmt: Or(
      '<if>', '<for>', '<while>', '<do>',
      '<return>', '<break>', '<continue>', '<throw>',
      '<nop>',
      // TODO: switch, try, yield, labeled statements
      [IN, '<block>', DE],
      // This means consume an indent pseudo-token, match expression,
      // consume a literal ';' token, consume a dedent psuedo-token.
      [IN, '<commaexpr.>', ';', DE],
    ),
    decl: Or('<let>', '<function>'),

    if: Or(
      [IN, IN, IN, 'if', DE, '(', '<expr>', ')', DE, '<block>', DE],
      [IN, IN, IN, IN, 'if', DE, '(', '<expr>', ')', DE, '<block>', DE,
       '<else>', DE],
    ),

    else: Or(
      ['else', IN, '<block>', DE],
      ['else', '<if>'],
    ),

    for: Or(
      [
        IN, IN, IN, 'for', DE, '(',
        Or(
          [
            Or('<forinit>', [IN, ';', DE], ';'),
            Or('<forcond>', [IN, ';', DE], ';'),
          ],
          [IN, IN, ';', DE, ';', DE],
        ),
        '<forincr_opt>',
        ')', DE, '<block>', DE
      ],
      // TODO: for...in, for...of
    ),

    forinit: Or('<let>', [IN, '<commaexpr.>', ';', DE]),
    forcond: [IN, '<expr>', ';', DE],
    forincr: '<commaexpr.>',

    while: [
      IN, IN, IN, 'while', DE, '(', '<expr>', ')', DE, '<block>', DE,
    ],

    do: [
      IN, IN, IN,
      'do', IN, '<block>', DE, DE, 'while', IN, '(', '<expr>', ')',
      DE, DE, ';', DE,
    ],

    return: Or(
      [IN, IN, 'return', DE, ';', DE],
      [IN, IN, 'return', '<expr>', DE, ';', DE],
      [IN, IN, 'return', DE, '(', '<expr>', ')', DE, ';'],
    ),

    throw: Or(
      [IN, IN, 'throw', '<expr>', DE, ';', DE],
      [IN, IN, 'throw', DE, '(', '<expr>', ')', DE, ';'],
    ),

    nop: Or(
      [IN, ';', DE],
      [IN, IN, ';', DE, ';', DE],
    ),

    label: idPattern,

    break: [IN, IN, 'break', '<label_opt>', DE, ';', DE],
    continue: [IN, IN, 'continue', '<label_opt>', DE, ';', DE],

    block: ['{', '<toplevels.>', '}'],

    let: [IN, '<letbody.>', ';', DE],

    letbody: Or(
      [IN, 'let', '<id>', DE],
      [IN, IN, 'let', '<id>', DE, '=', '<commael.>', DE],
      [IN, IN, 'let', '<id>', DE, ':', '<type>', DE],
      [IN, IN, IN, 'let', '<id>', DE, ':', '<type>', DE, '=', '<commael.>', DE],
      [IN, '<letbody.>', ',', '<letrest.>', DE],
    ),

    letrest: Or(
      [IN, '<id>', DE],
      [IN, IN, '<id>', DE, '=', '<expr>', DE],
      [IN, IN, '<id>', DE, ':', '<type>', DE],
      [IN, IN, IN, '<id>', DE, ':', '<type>', DE, '=', '<expr>', DE],
      [IN, '<letrest.>', ',', '<letrest.>', DE],
    ),

    type: Or(
      '<nominaltype>',
      '<generictype>',
      '<uniontype>',
      // TODO: record type
      [IN, '(', '<type.>', ')', DE],
    ),
    nominaltype: [IN, '<id>', DE],
    generictype: [IN, '<type.>', '<', '<typeparams>', '>', DE],
    uniontype: [IN, Or('<uniontype.>', '<type.>'), '|', '<type.>', DE],
    typeparams: Or(
      '<type.>',
      [IN, '<type.>', ',', '<typeparams.>', DE],
    ),
    rettype: '<type.>',

    function: [
      IN, IN, IN, 'function', idPattern, DE, '(', '<formals_opt>', ')', DE,
      Or(
        [ '<block>', DE],
        [ ':', IN, '<rettype>', '<block>', DE, DE],
      )
    ],
    formals: Or(
      [IN, '<formal>', ',', '<formals_opt.>', DE],
      ['<formal>'],
    ),

    formal: '<letrest.>',

    commaexpr: Or(
      '<commaop>',
      '<expr>',
    ),
    commaop: [IN, '<commael.>', ',', Or('<commaop.>', '<commael.>', []), DE],
    commael: Or(
      '<expr>',
      Garbage({ stopBefore: [',', ...closeBrackets] }),
    ),

    expr: Or(
      '<literal>',
      '<id>',
      '<template>',
      // Parentheses for grouping
      [
        IN, '(',
        Or('<commaop>', '<expr.>', Garbage({ stopBefore: [')'] })),
        ')', DE
      ],
      '<array>',
      '<prefix>',
      '<infix>',
      '<call>',
      '<new>',
      '<obj>',
      '<postfix>',
      '<member>',
      // TODO: instanceof
      [IN, '(',
       Garbage({ stopBefore: [',', ';', ...closeBrackets], stopAfter: [')'] }),
       DE],
    ),

    literal: Or([IN, litPattern, DE], litPattern),
    id: Or([IN, idPattern, DE], idPattern),
    array: [
      IN, '[',
      Or('<arrayels.>', '<expr>', Garbage({ stopBefore: [']']})),
      ']', DE],

    arrayels: [IN, '<arrayel.>', ',', Opt(Or('<arrayels.>', '<arrayel.>')), DE],
    arrayel: Or(
      '<expr>',
      '<spread>',
      // TODO: elision as in [a,,b] and [a,,,b]
      Garbage({ stopBefore: [',', ...closeBrackets]}),
    ),
    spread: [IN, '...', '<expr>', DE],

    infix: Or(
      [IN, '<expr>', /^[+\-*/=%^&|!<>.]+$/, '<expr>', DE],
      [IN, '<expr>', /^[?]$/, '<expr>', /^:$/, '<expr>', DE],
    ),
    call: [IN, '<expr>', '(', '<actuals_opt>', ')', DE],
    // Matches a JS style {propname:value} expr.
    obj: [IN, '{', Opt('<props>'), '}', DE],
    props: Or(
      [IN, '<props.>', ',', Opt('<props.>'), DE],
      [IN, IN, '<id>', DE, ':', '<expr>'],
    ),
    prefix: [IN, /^[!\-+]/, '<expr>', DE],
    postfix: [IN, '<expr>', /^(?:--|\+\+)$/, DE],
    new: [IN, IN, 'new', '<type.>', DE, '(', '<actuals_opt>', ')', DE],
    member: [IN, '<expr>', '[', '<commaexpr.>', ']', DE],

    template: [
      IN,
      Opt([NegLA([ '(', IN, /^`/]), '<ttag>']),
      '(', IN,
      Or(
        [/^`(?:[^`\\]|\\[\s\S])*`$/],
        [/^`(?:[^`\\]|\\[\s\S])*[$]\{$/, DE,
         '<hole>',
         Opt(Rep([IN, /^\}(?:[^`\\]|\\[\s\S])*[$]\{$/, DE, '<hole>'])),
         IN, /^\}(?:[^`\\]|\\[\s\S])*`$/],
      ),
      DE, ')', DE
    ],
    hole: [
      IN, '(', Or('<commaexpr.>', Garbage({ stopBefore: [')'] })), ')', DE
    ],
    ttag: [
      '<expr>',
    ],

    actuals: Or(
      '<commaop.>',
      '<expr>',
      Garbage({ stopBefore: [')'], requireSome: true }),
    ),
  };
}
</script>

<script class="visible hoisted" id="grammar-support-for-quasis">
makeToyLanguageGrammar = ((oldMakeGrammar) => ((combinators) => {
  const { Opt/*ional*/, Rep/*etition*/, Or, IN, DE } = combinators;

  const productions = {
    ...oldMakeGrammar(combinators),

    // Extra productions for quasi-quoting
    qtree:  [IN, '\\{', Opt(Rep(Or('<qhole>', '<qinner>'))), '}', DE],
    qast:   [IN, '\\(', Or('<expr>', '<toplevel>'), ')', DE],
    qnodes: Opt(Rep(Or('<qhole>', '<qinner>', '<qleaf>'))),
    qhole:  [IN, '${', '<commaexpr.>', '}', DE],
    qinner: [IN, '<qnodes.>', DE],
    qleaf:  /^/,  // Matches any token.
  };
  // A quasi-quotation is an expression.
  productions.expr = Or(
    '<qtree>',
    '<qast>',
    productions.expr
  );
  // Since <expr> and <toplevel> can appear inside \( ... ),
  // we need to allow qholes in important places.
  for (const name of ['expr', 'label', 'stmt', 'type']) {
    if (!productions[name]) { throw new Error(name); }
    productions[name] = Or('<qhole>', productions[name]);
  }
  return productions;
}))(makeToyLanguageGrammar);
</script>

<p>Unless otherwise stated, examples hereafter use this transform from
parse trees to ASTs:</p>

<script class="visible">
const toyLanguageGrammar = new combinators.Grammar(
  makeToyLanguageGrammar(combinators));
</script>

<p>The rest of the end-to-end tests are a bit duplicative.</p>

<details>
  <summary>Let statement tests</summary>
  <script>
    ta(
      'let x;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [{ type: 'id', children: ['x'] }]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x = 1;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    {
                      type: 'id',
                      children: ['x']
                    },
                    {
                      type: 'expr',
                      children: [{ type: 'literal', children: ['1'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x : number;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    {
                      type: 'id',
                      children: ['x']
                    },
                    {
                      type: 'type',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['number'] }]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x : number = 1;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    {
                      type: 'id',
                      children: ['x']
                    },
                    {
                      type: 'type',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['number'] }]
                        }
                      ]
                    },
                    {
                      type: 'expr',
                      children: [{ type: 'literal', children: ['1'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x : number, y = 1;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    { type: 'id', children: ['x'] },
                    {
                      type: 'type',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['number'] }]
                        }
                      ]
                    },
                    { type: 'id', children: ['y'] },
                    {
                      type: 'expr',
                      children: [{ type: 'literal', children: ['1'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x, y, z;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    { type: 'id', children: ['x'] },
                    { type: 'id', children: ['y'] },
                    { type: 'id', children: ['z'] }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x : T<A, B> | false = a < b && new T();',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    { type: 'id', children: ['x'] },
                    {
                      type: 'type',
                      children: [
                        {
                          type: 'uniontype',
                          children: [
                            {
                              type: 'generictype',
                              children: [
                                {
                                  type: 'nominaltype',
                                  children: [{ type: 'id', children: ['T'] }]
                                },
                                {
                                  type: 'typeparams',
                                  children: [
                                    {
                                      type: 'nominaltype',
                                      children: [{ type: 'id', children: ['A'] }]
                                    },
                                    {
                                      type: 'nominaltype',
                                      children: [{ type: 'id', children: ['B'] }]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              type: 'nominaltype',
                              children: [{ type: 'id', children: ['false'] }]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'infix',
                          children: [
                            {
                              type: 'expr',
                              children: [
                                {
                                  type: 'infix',
                                  children: [
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['a'] }]
                                    },
                                    '<',
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['b'] }]
                                    }
                                  ]
                                }
                              ]
                            },
                            '&&',
                            {
                              type: 'expr',
                              children: [
                                {
                                  type: 'new',
                                  children: [
                                    {
                                      type: 'nominaltype',
                                      children: [{ type: 'id', children: ['T'] }]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'x = new T<u>(a < b, c > d);',
      [
        {
          type: 'program',
          children: [
            {
              type: 'expr',
              children: [
                {
                  type: 'infix',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['x'] }]
                    },
                    '=',
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'new',
                          children: [
                            {
                              type: 'generictype',
                              children: [
                                {
                                  type: 'nominaltype',
                                  children: [{ type: 'id', children: ['T'] }]
                                },
                                {
                                  type: 'typeparams',
                                  children: [
                                    {
                                      type: 'nominaltype',
                                      children: [{ type: 'id', children: ['u'] }]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              type: 'actuals',
                              children: [
                                {
                                  type: 'expr',
                                  children: [
                                    {
                                      type: 'infix',
                                      children: [
                                        {
                                          type: 'expr',
                                          children: [{ type: 'id', children: ['a'] }]
                                        },
                                        '<',
                                        {
                                          type: 'expr',
                                          children: [{ type: 'id', children: ['b'] }]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  type: 'expr',
                                  children: [
                                    {
                                      type: 'infix',
                                      children: [
                                        {
                                          type: 'expr',
                                          children: [{ type: 'id', children: ['c'] }]
                                        },
                                        '>',
                                        {
                                          type: 'expr',
                                          children: [{ type: 'id', children: ['d'] }]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
  </script>
</details>

<details>
  <summary>For loop tests</summary>
  <script>
    ta(
      'for (let x : number = 1, n = 10; i < n; ++i) { body; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'forinit',
                  children: [
                    {
                      type: 'let',
                      children: [
                        { type: 'id', children: ['x'] },
                        {
                          type: 'type',
                          children: [
                            {
                              type: 'nominaltype',
                              children: [{ type: 'id', children: ['number'] }]
                            }
                          ]
                        },
                        {
                          type: 'expr',
                          children: [{ type: 'literal', children: ['1'] }]
                        },
                        { type: 'id', children: ['n'] },
                        {
                          type: 'expr',
                          children: [{ type: 'literal', children: ['10'] }]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'forcond',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'infix',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['i'] }]
                            },
                            '<',
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['n'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'forincr',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'prefix',
                          children: [
                            '++',
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['i'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'block',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['body'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'for (x = 1, y = 10; x < y; ++x, --y) { console.log(x, y); }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'forinit',
                  children: [
                    {
                      type: 'commaop',
                      children: [
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'infix',
                              children: [
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['x'] }]
                                },
                                '=',
                                {
                                  type: 'expr',
                                  children: [{ type: 'literal', children: ['1'] }]
                                }
                                  ]
                            }
                          ]
                        },
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'infix',
                              children: [
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['y'] }]
                                },
                                '=',
                                {
                                  type: 'expr',
                                  children: [{ type: 'literal', children: ['10'] }]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'forcond',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'infix',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['x'] }]
                            },
                            '<',
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['y'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'forincr',
                  children: [
                    {
                      type: 'commaop',
                      children: [
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'prefix',
                              children: [
                                '++',
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['x'] }]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'prefix',
                              children: [
                                '--',
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['y'] }]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'block',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'call',
                          children: [
                            {
                              type: 'expr',
                              children: [
                                {
                                  type: 'infix',
                                  children: [
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['console'] }]
                                    },
                                    '.',
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['log'] }]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              type: 'actuals',
                              children: [
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['x'] }]
                                },
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['y'] }]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'for (; f();) { g(); }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'forcond',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'call',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['f'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'block',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'call',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['g'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'for (;;) { if (f()) { break; } }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'block',
                  children: [
                    {
                      type: 'if',
                      children: [
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'call',
                              children: [
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['f'] }]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          type: 'block',
                          children: [{ type: 'break', children: [] }]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'for (;; f()) { break label; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'forincr',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'call',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['f'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'block',
                  children: [
                    {
                      type: 'break',
                      children: [{ type: 'label', children: ['label'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]    );
  </script>
</details>

<details>
  <summary>Function declaration tests</summary>
  <script>
    ta(
      'function f() { return; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'function',
                  children: [
                    'f',
                    {
                      type: 'block',
                      children: [{ type: 'return', children: [] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'function f(x) { return x; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'function',
                  children: [
                    'f',
                    {
                      type: 'formals',
                      children: [
                        {
                          type: 'formal',
                          children: [{ type: 'id', children: ['x'] }]
                        }
                      ]
                    },
                    {
                      type: 'block',
                      children: [
                        {
                          type: 'return',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['x'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'function f(x: number): number { return (x); }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'function',
                  children: [
                    'f',
                    {
                      type: 'formals',
                      children: [
                        {
                          type: 'formal',
                          children: [
                            { type: 'id', children: ['x'] },
                            {
                              type: 'type',
                              children: [
                                {
                                  type: 'nominaltype',
                                  children: [{ type: 'id', children: ['number'] }]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      type: 'rettype',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['number'] }]
                        }
                      ]
                    },
                    {
                      type: 'block',
                      children: [
                        {
                          type: 'return',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['x'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'function f(x: number, y = null): number|string { return y ? x : "" + x; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'function',
                  children: [
                    'f',
                    {
                      type: 'formals',
                      children: [
                        {
                          type: 'formal',
                          children: [
                            { type: 'id', children: ['x'] },
                            {
                              type: 'type',
                              children: [
                                {
                                  type: 'nominaltype',
                                  children: [{ type: 'id', children: ['number'] }]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          type: 'formal',
                          children: [
                            { type: 'id', children: ['y'] },
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['null'] }]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      type: 'rettype',
                      children: [
                        {
                          type: 'uniontype',
                          children: [
                            {
                              type: 'nominaltype',
                              children: [{ type: 'id', children: ['number'] }]
                            },
                            {
                              type: 'nominaltype',
                              children: [{ type: 'id', children: ['string'] }]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      type: 'block',
                      children: [
                        {
                          type: 'return',
                          children: [
                            {
                              type: 'expr',
                              children: [
                                {
                                  type: 'infix',
                                  children: [
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['y'] }]
                                    },
                                    '?',
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['x'] }]
                                    },
                                    ':',
                                    {
                                      type: 'expr',
                                      children: [
                                        {
                                          type: 'infix',
                                          children: [
                                            {
                                              type: 'expr',
                                              children: [{ type: 'literal', children: ['\"\"'] }]
                                            },
                                            '+',
                                            {
                                              type: 'expr',
                                              children: [{ type: 'id', children: ['x'] }]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
  </script>
</details>

<details>
  <summary>More expression tests</summary>
  <script>
    ta(
      'new T<A, B>(x)',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'new',
              children: [
                {
                  type: 'generictype',
                  children: [
                    {
                      type: 'nominaltype',
                      children: [{ type: 'id', children: ['T'] }]
                    },
                    {
                      type: 'typeparams',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['A'] }]
                        },
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['B'] }]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'actuals',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['x'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '[a, ...b, c]',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'array',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['a'] }]
                },
                {
                  type: 'spread',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['b'] }]
                    }
                  ]
                },
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['c'] }]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      'array[i]',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'member',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['array'] }]
                },
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['i'] }]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '/a*|b+|[cd]/g',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'literal',
              children: ['/a*|b+|[cd]/g']
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '`a${ b }c`',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'template',
              children: [
                '`a${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['b'] }]
                    }
                  ]
                },
                '}c`'
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '`....`',
      [
        {
          type: 'expr',
          children: [{ type: 'template', children: ['`....`'] }]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '`a${ b }\${c}${d,d}...${e}`',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'template',
              children: [
                '`a${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['b'] }]
                    }
                  ]
                },
                '}${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['c'] }]
                    }
                  ]
                },
                '}${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'commaop',
                      children: [
                        {
                          type: 'expr',
                          children: [{ type: 'id', children: ['d'] }]
                        },
                        {
                          type: 'expr',
                          children: [{ type: 'id', children: ['d'] }]
                        }
                      ]
                    }
                  ]
                },
                '}...${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['e'] }]
                    }
                  ]
                },
                '}`'
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '-1',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'prefix',
              children: [
                '-',
                {
                  type: 'expr',
                  children: [{ type: 'literal', children: ['1'] }]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '.1e-2',
      [
        {
          type: 'expr',
          children: [{ type: 'literal', children: ['.1e-2'] }]
        }
      ],
      { start: 'expr' }
    );
    ta(
      'f`a${ b }`',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'template',
              children: [
                {
                  type: 'ttag',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['f'] }]
                    }
                  ]
                },
                '`a${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['b'] }]
                    }
                  ]
                },
                '}`'
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '[x,]',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'array',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['x'] }]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
  </script>
</details>

<details>
  <summary>More statement tests</summary>
  <script>
    ta(
      '{;}',
      [
        {
          type: 'program',
          children: [
            {
              type: 'block',
              children: [{ type: 'nop', children: [] }]
            }
          ]
        }
      ]
    );
    ta(
      '{;;}',
      [
        {
          type: 'program',
          children: [
            {
              type: 'block',
              children: [{ type: 'nop', children: [] }]
            }
          ]
        }
      ]
    );
    ta(
      'while (b) {}',
      [
        {
          type: 'program',
          children: [
            {
              type: 'while',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['b'] }]
                },
                { type: 'block', children: [] }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'while (b) {} {}',
      [
        {
          type: 'program',
          children: [
            {
              type: 'while',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['b'] }]
                },
                { type: 'block', children: [] }
              ]
            },
            { type: 'block', children: [] }
          ]
        }
      ]
    );
  </script>
</details>

<h2 id="code-as-data">Code as data</h2>

<p>
  The parsing scheme outlined above provides for a limited kind of
  homoiconicity; tools less complex than the compiler can consume
  fragments of code, and those rules would extend to new special
  forms.
</p>

<p>
  Homoiconicity also makes it easier for programs to operate on or
  produce program fragments.  Quoting from
  <a href="https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20(Bawden).pdf">&ldquo;Quasiquotation
  in Lisp&rdquo; (Bawden 1999)</a>:
</p>

<blockquote>
  <p>
    Quasiquotation is the technology commonly used in Lisp to write
    program-generating programs.
  </p>
  <p>
    &hellip;
  </p>
  <p>
    The backquote character (`) introduces a quasiquotation &hellip;
    Inside the quasiquotation, the comma character (,) marks
    expressions whose values are to be substituted into the result.
  </p>
  <p>
    &hellip;
  </p>
  <p>
    S-expressions were at the core of McCarthy's original version of
    Lisp.  The ability to manipulate programs as data has always been
    an important part of what Lisp is all about.  But without
    quasiquotation, actually working with S-expressions can be
    painful.
  </p>
</blockquote>

<p>
  So quasiquotation requires two affordances:
</p>
<ul>
  <li>Syntax to &ldquo;quote&rdquo; part of a parse tree.</li>
  <li>Syntax to embed an unquoted expression inside a quoted parse tree.</li>
</ul>

<p>
  <a href="#template-literal-example">JavaScript-esque template literals</a>
  provide this, but run afoul of:
</p>

<blockquote>
  <p>
    The string substitution that underlies [<code>fprintf</code>] has <i>no</i>
    understanding of the syntactic structure of the programming language
    being generated.
  </p>
</blockquote>

<p>
  Javascript's <i>tagged</i> template literals allow that, but require
  implementing a parser for code with holes and lose source metadata.
  This section shows how this operator precedence scheme can meet the
  goals of quasi-quotation within a C-like language.
</p>

<blockquote>
  <p>&hellip; goals for a successful implementation of quasiquotation:</p>
  <ul>
    <li>
      Quasiquotation should enable programmers to write down what they
    want the output to look like, modified only slightly in order to
      parameterize it.
    <li>
      The parameter expressions should appear inside the template, in
      the positions where their values will be inserted.
    <li>
      The underlying data structures manipulated by quasiquotation should
      be rich enough to represent recursively defined structures such
      as expressions.
  </ul>
</blockquote>

<pre id="unhoist-extra-brackets-for-quasis"></pre>

<p>
  Defining &ldquo;<code>\{</code>&rdquo; and &ldquo;<code>\(</code>&rdquo; as
  bracket operators, enables quoting statements and expressions.
  Defining &ldquo;<code>${</code>&rdquo; as an expression operator allows
  embedding unquoted expressions inside quoted code.
  Then we add some extra productions to the toy grammar, and augment a
  few existing ones.
</p>

<pre id="unhoist-grammar-support-for-quasis"></pre>

<p>
  With that &ldquo;<code>\{</code>&hellip;<code>}</code>&rdquo; embeds
  a parse sub-tree as data.  <span class="type quasi">qtree</span> and
  other bluish AST nodes recreate the parse tree structure of the
  quoted portions.
</p>

<script>
  ta(
    'let blockParseTreeData = \\{ f(\${ x }); };',
    [
      {
        type: 'program',
        children: [
          {
            type: 'decl',
            children: [
              {
                type: 'let',
                children: [
                  { type: 'id', children: ['blockParseTreeData'] },
                  {
                    type: 'expr',
                    children: [
                      {
                        type: 'qtree',
                        children: [
                          {
                            type: 'qinner',
                            children: [
                              {
                                type: 'qinner',
                                children: [
                                  {
                                    type: 'qinner',
                                    children: [{ type: 'qleaf', children: ['f'] }]
                                  },
                                  { type: 'qleaf', children: ['('] },
                                  {
                                    type: 'qhole',
                                    children: [
                                      {
                                        type: 'expr',
                                        children: [{ type: 'id', children: ['x'] }]
                                      }
                                    ]
                                  },
                                  { type: 'qleaf', children: [')'] }
                                ]
                              },
                              { type: 'qleaf', children: [';'] }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
</script>

<p>
  If <span class="type quasi">qinner</span> behaves
  like <span class="type">array</span> and <span class="type
  quasi">qleaf</span> like <span class="type">literal</span> then that
  quasiquotation would produce a tree like data structure.
  The <span class="type quasi">qhole</span>
  breaks back out into unquoted AST nodes that could contribute to the
  larger data structure.
</p>

<p>
  Since &ldquo;<code>\{</code>&hellip;<code>}</code>&rdquo; uses the
  cover grammar, its consumers can recognize forms not allowed by the
  parse-tree &rarr; AST phase.  In this sense, it is similar to Common
  Lisp's <code>read</code> which recognizes some characters
  (&lsquo;[&rsquo;, &lsquo;]&rsquo;, &lsquo;{&rsquo;, &lsquo;}&rsquo;,
  &lsquo;?&rsquo;, and &lsquo;!&rsquo;) which are not used by Common
  Lisp syntax but which are explicitly reserved for user extensions.
</p>

<blockquote>
  <p>
    List structure is not quite as stark a representation [of code] as
    character strings, but it is still pretty low-level.  Perhaps we
    would be happier if, instead of manipulating lists, our
    quasiquotation technology manipulated objects from a set of
    abstract data types that were designed specifically for each of the
    various different constructs in our language (variables,
    expressions, definitions, <code>cond</code>-clases, etc.).  After
    abandoning character strings as too low-level it seems very
    natural to keep moving towards even highler-level representations.
  </p>
</blockquote>

<p>
  Separately, &ldquo;<code>\(</code>&hellip;<code>)</code>&rdquo;
  quotes an AST with holes.  These two constructs let program
  generators deal with program fragment templates at two different
  levels of abstraction: parse trees and ASTs.
</p>

<script>
  ta(
    'let ifAst = \\( if (\${ x }) { f(\${ x }); } );',
    [
      {
        type: 'program',
        children: [
          {
            type: 'decl',
            children: [
              {
                type: 'let',
                children: [
                  { type: 'id', children: ['ifAst'] },
                  {
                    type: 'expr',
                    children: [
                      {
                        type: 'qast',
                        children: [
                          {
                            type: 'toplevel',
                            children: [
                              {
                                type: 'if',
                                children: [
                                  {
                                    type: 'expr',
                                    children: [
                                      {
                                        type: 'qhole',
                                        children: [
                                          {
                                            type: 'expr',
                                            children: [{ type: 'id', children: ['x'] }]
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  {
                                    type: 'block',
                                    children: [
                                      {
                                        type: 'expr',
                                        children: [
                                          {
                                            type: 'call',
                                            children: [
                                              {
                                                type: 'expr',
                                                children: [{ type: 'id', children: ['f'] }]
                                              },
                                              {
                                                type: 'actuals',
                                                children: [
                                                  {
                                                    type: 'expr',
                                                    children: [
                                                      {
                                                        type: 'qhole',
                                                        children: [
                                                          {
                                                            type: 'expr',
                                                            children: [{ type: 'id', children: ['x'] }]
                                                          }
                                                        ]
                                                      }
                                                    ]
                                                  }
                                                ]
                                              }
                                            ]
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
</script>

<h3>Risk: Lock-in</h3>

<p>
  The second kind of quasiquotation exposes details of
  language specification abstracts to user code.  Some language
  designers have expressed concern that this may make it harder to
  evolve the language.
  <a href="https://esdiscuss.org/notes/2018-05-24">On a
  proposal for a binary encoding for EcmaScript AST</a>:
</p>

<blockquote>
  <p>
    <b>WH</b>: compatibility means existing nodes strips compiled
    continue to work as we upgrade the language. But as ECMAScript
    evolves the same text source code may compile to different nodes
    even if they don't use new constructs.  &hellip; The Hyrum's Law
    challenge is that folks may come to rely on source text compiling
    to a specific AST.
  </p>
</blockquote>

<p>
  The parse tree form has fewer rules, but there is still a non-zero
  lock-in risk:
</p>

<blockquote>
  <p>
    <b>WH</b>: In this committee it came up discussing changing
    associativity of <code>||</code> from left-to-right to
    right-to-left in order to properly support one of the variants of
    the <code>??</code> proposal.  It's invisible from within
    ECMAScript but would change which AST gets generated. There was
    opposition related to the effect this would have on Babel's ASTs.
  </p>
</blockquote>

<p>
  In Lisp, the grammar for S-expressions is very simple and stable.
  Without experience maintaining a language whose initial parsing is
  based on cover grammars &amp; precedence table, it's hard to say how
  stable these are over time, or what strategies are effective in
  working around compatibility problems due to Hyrum's law.
</p>


<h2 id="limitations">Limitations & CounterExamples</h2>

<p>This parser scheme produces a parse tree that groups tokens for some C-like languages
into a tree that is unambiguous and which can be processed into an AST.</p>

<p>It deals poorly with some idioms and grammatical constructions.</p>

<script>
  function counterExample(input, { parseFn } = {}) {
    const div = document.createElement('div');
    div.className = 'testcase';
    if (document.currentScript) {
      document.currentScript.parentNode.insertBefore(div, document.currentScript);
    } else {
      document.body.appendChild(div);
    }

    deferTest(
      () => {
        const parseTree = (parseFn || parse)(preparseTokens(lex(input)));

        div.innerHTML = html`
          <details>
            <summary>
              <code class="prettyprint">${ input }</code><br>
              ${ formatTNode(parseTree) }
            </summary>
            <pre>${ JSON.stringify(parseTree, replaceTokenWithTokenText, 2) }</pre>
          </details>`;
      });
  }
</script>

<h3 id="angle-bracket-ambiguity">Angle bracket ambiguity</h3>

<p>As <a href="#bracket-ambig">previously discussed</a>, there is a deep,
unavoidable ambiguity between &lsquo;&lt;&rsquo; as a comparison operator and
as a bracket around type parameters.</p>

<script>
  counterExample('template <class T> T mode(vector<T>& xs)');
  counterExample('unnecessary_statement_label: a < b && c > d && sideEffect();');
</script>

<p>Unless there is a closed set of operators that precisely
distinguish type contexts from exception context, this is
incorrigible.  <code>template</code> could be a prefix operator, but
operator precedence parsing cannot take into account questions like
&ldquo;Is <code>vector</code> a type name?&rdquo;</p>

<h3 id="flow-control-without-brackets">Flow control without brackets</h3>

<script>
  counterExample('if (cond) --x;');
</script>

<p>This is subideal because the low precedence &ldquo;<code>--</code>&rdquo; operator
  captures the apparent function call <code>if (cond)</code> since it can function
  as both a prefix and postfix operator.
  This can be partially fixed by defining <code>if</code> and friends as low-priority
  prefix operators, as is already done for <code>do</code>.
</p>

<script class="visible">
function altCanNest(outers, inner) {
  let outer = outers(0);
  if (outer.op.tok === '{' && outer.op.type === INFIX
      && inner.op.tok === 'if') {
    return true;
  }
  return canNest(outers, inner);
}

const { parse: altParse } = makeParser(
  new ClosedOperatorSet([
    ...operators,
    { type: PREFIX, tok: 'if', prec: -1 },
  ]),
  altCanNest);
</script>

<script>
  counterExample(
    'if (cond) --x;',
    { parseFn: altParse }
  );
</script>

<p>The <code>if</code> node is now self contained, but without some
invisible adjacency operator auto-inserted between the close
parenthesis and <code>--</code> the parse tree is still odd.  Worse,
the <code>--</code> acts as a postfix operator on <code>if</code> so this
alternate nesting scheme would require extra rules to prevent postfix
operators applying to <code>if</code>.
</p>

<p>Worse, this is no longer homoiconic.  New operators that want to syntactically mimic the
structure of <code>if</code> need to have their own entry in the precedence table.</p>

<h3 id="else-else-if">Else Else If</h3>

<p>The <a href="#cover-grammar">cover grammar</a> allows <code>else
if</code> to follow <code>else</code> which might introduce some
shift-reduce style problems.  This may be corrigible by
tweaking <code>canNest</code> with respect to a prefix <code>if</code> and
infix <code>else</code> or by recognizing <code>else if</code> as a separate,
two token infix operator.</p>

<script>
  counterExample(
    'if (a) if (b) x; else y; else if (c) z;',
    { parseFn: altParse }
  );
</script>

<h3 id="flow-control-without-parentheses">Flow control without parentheses</h3>

<p>Go makes parentheses optional around flow control constructs; it
uses <code class="prettyprint">for init;cond;incr { }</code> instead
of <code class="prettyprint">for (init;cond;incr) { }</code>.</p>

<script>
  counterExample('if a && b { doTheThing() }');
</script>

<p>This is subideal because the low priority <code>&&</code> operator captures the higher
  priority infix <code>{}</code> operator.
  Again, defining infix curly brackets as low-priority can probably address this
  but the author has not proven this.
  (TODO: try this.  It shouldn't break do{}while)
</p>

<script>
  counterExample('if a && b { doTheThing() }', { parseFn: altParse });
</script>

<h3 id="scoping">Scoping</h3>

<p>It would be nice if tools could make high-quality-ish conclusions about chunks of
a program.  One of the most important things is to match declarations with uses, which is
often a prerequisite to identifying free variables.</p>

<p>The author has been unable to find a generic algorithm that identifies declarations.</p>

<p>It is generally the case that in <code class="prettyprint">keyword
(...) {...}</code>  any declarations immediately inside the
parentheses are in scope for the code in the curly brackets.</p>

<p>This is not sufficient.

<ol>
  <li>
    <p>To recognize a declaration in C, C++, and Java, you need to have a list of symbols that are
    type names.  For example, in C++, <code>{x * y;}</code> is a declaration of a pointer when
    <code>x</code> is a type name, or an invocation of the infix &lsquo;*&rsquo; operator when
    it is not.</p>

    <p>In Java, inner classes can be inherited, so local analysis is not
    sufficient to tell whether <code>x.y.z</code> is a reference to a static member of
    unqualified type <code>x</code>, a reference to a member of a (possibly inherited)
    field <code>x</code>, or a reference to a static member of a class with the absolute
    name <code>x.y</code>.</p>

    <p>Languages that consistently set declarations apart with a keyword
    like <code>let</code>, <code>const</code>, <code>val</code>,
    or <code>var</code> could define those as prefix operators and
    may avoid this problem.</p>
  </li>
  <li>
    <p>Code inside a class declaration in languages like Java and C++ inherit masking symbols,
      so you need to understand the inheritance structure to draw conslusions about variables
      in scope.
    </p>

    <p>Languages that require <code>this.x</code> to access fields, or that shorten this to
    <code>.x</code> by defining &lsquo;.&rsquo; as a prefix operator can avoid this problem.</p>
  </li>
</ol>

<h2 id="suggestions">Suggestions</h2>

<p>If you wish your language to be parseable by schemes like this:</p>

<ul>
  <li>
    Divide parsing into these stages:
    <ol>
      <li><a href="#lexing">Lexing</a>: breaking the input into tokens.
        (See <a href="#scannerless">note on scannerless parsing</a>.)</li>
      <li><a href="#token-preparsing">Preparsing</a>: inserting synthetic tokens to group
        complicated lexical constructs like template literals or JSX/E4X tags.</li>
      <li><a href="#parsing">Parsing</a>: deriving a parse tree from the token stream</li>
      <li><a href="#well-formedness">Checking</a>: checking the parse tree for well-formedness</li>
      <li><a href="#combinators">Abstracting</a>: converting the parse
        tree to an AST (abstract-syntax-tree) which is a suitable input
        to a compiler or interpreter.</li>
    </ol>
    Document each so that tools can operate at an appropriate level.
  <li>
    Avoid <a href="#bracket-ambig">angle bracket ambiguity</a>.
    <ul>
      <li>Do not use <code>&lt;&hellip;&gt;</code> to group type parameters.
        For example, Scala
        <a href="https://docs.scala-lang.org/tour/generic-classes.html">uses
          <code>[&hellip;]</code>
        </a>.
      <li>or ensure that lexical analysis (a left to right pass over
        tokens that may keep a bracket stack) alone can disambiguate.
        It is important to be able to distinguish, without a list of type names:
        <ul>
          <li>Parentheses that group formal parameters from those that group
            actual parameters.</li>
          <li>Declarations from assignment statements.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Craft declaration and flow control constructs to fit within the
      <a href="#cover-grammar">cover grammar</a> modulo explicitly
      handled legacy constructs like <code>do...while...</code> and
      <code>switch(...){case...:...}</code>.</p>
    <p>Specifically:</p>
    <ul>
      <li>require parentheses unlike Go and Swift</li>
      <li>make brackets non optional like Go and Swift</li>
    </ul>
  </li>
  <li>
    <p>Avoid layered namespaces like Java's layering of explicitly
    imported type names, wildcard imported type names, explicitly
    imported static properties and methods, wildcard imported
    properties and methods, local identifiers, inherited properties
    and methods.</p>

    <p>Make local identifiers always mask external definitions and
    maybe use a lightweight convention like <code>.identifier</code>
    instead of just <code>this.identifier</code> so that tools can
    confidently distinguish local references from references that can
    only be resolved with knowledge from other source files.</p>
  </li>
  <li>
    <p>
      If you must automagically insert semicolons, leave it to tooling
      like IDEs, and do it based on
      <a href="#lexical-asi">lexical analysis</a>.
    </p>
  </li>
</ul>

<h2 id="summary">Summary</h2>

<p>
  Separating parsing of coarse-level structure from fine-grained
  structure provides benefits including: better tool support during
  development, easier partial program analysis, language
  extensibility, and metaprogramming.
</p>

<p>
  Some simple guidelines make it easier to craft a new language that
  gets these benefits and uses a syntax familiar to developers who
  work with widely-used, C-like languages.
</p>

<p>
  Ambiguity between less-than &amp; angle-brackets means that not all
  existing languages cannot be migrated to this scheme, although,
  strangely, some complex languages like TypeScript may be migratable.
  There are clear precedents that show how to design around this ambiguity.
</p>

<p>
  That ambiguity avoided, operator precedence parsers can parse C-like
  languages.  (Operator precedence parsers have not been widely used
  for parsing C-like languages, except in conjunction with RD, though
  Perl 6's
  <a href="https://www.pmichaud.com/2006/pres/yapc-parsers/slide28.html">Parser Grammar Engine</a>
  may be one precedent.)
</p>

<p>
  This operator precedence parsers degrades gracefully given partial
  and broken inputs.  It combines a small fixed set of rules with an
  extensible operator partial-order, so also meets the extensibility
  goal.
</p>

<p>
  The same techniques that allow grammar extensibility, also allow
  extensible quasiquotation similar to Common Lisp's <code>read</code>.
</p>



<h2 id="try-it-out">Try it out</h2>

<table id="tio-table">
  <tbody>
    <tr>
      <th>Input</th>
      <td><code id="tio-input"></code></td>
    <tr>
      <th>Tokens</th>
      <td id="tio-tokens"></td>
    <tr>
      <th>Parse Tree</th>
      <td id="tio-parse-tree"></td>
    <tr id="tio-problems-row">
      <th>Problems</th>
      <td id="tio-problems"></td>
    <tr>
      <th>Flat Tree</th>
      <td id="tio-flat-tree"></td>
    <tr>
      <th title="abstract syntax tree">AST</th>
      <td id="tio-ast"></td>
    <tr>
      <th>Parts of Speech</th>
      <td id="tio-pos"></td>
</table>

<script>
  // Handles the Try it out form.  Fills the output table from form inputs.
  function tryItOut(srcText) {
    const table = document.getElementById('tio-table');
    const prodsel = document.getElementById('production-select')

    console.group(srcText);
    try {
      table.querySelector('#tio-input').textContent = srcText;

      let problem = false;
      let tokens = [];
      try {
        tokens = Array.from(preparseTokens(lex(
          srcText,
          {
            onLexError() {
              problem = true;
            }
          })));
      } catch (ex) {
        console.error(ex);
        problem = true;
      }

      table.querySelector('#tio-tokens').innerHTML =
        formatTokens(tokens, problem);

      let parseTree;
      try {
        parseTree = parse(tokens);
      } catch (ex) {
        parseTree = ex instanceof Error ? ex : new Error(ex);
        console.error(ex);
      }

      table.querySelector('#tio-parse-tree').innerHTML =
        parseTree instanceof Error
        ? html`<i>${ parseTree.message || 'Error' }</i>`
        : formatTNode(parseTree);

      let ast = new Error('parse tree unavailable');
      let flatParseTree = ast;
      let problems = ast;

      if (!(parseTree instanceof Error)) {
        try {
          problems = checkParseTree(parseTree);
        } catch (ex) {
          problems = ex instanceof Error ? ex : new Error(ex);
          console.error(ex);
        }
        try {
          flatParseTree = flattenParseTreeToPseudoTokens(parseTree);
        } catch (ex) {
          flatParseTree = ex instanceof Error ? ex : new Error(ex);
          console.error(ex);
        }
      }

      table.querySelector('#tio-problems').innerHTML =
        problems instanceof Error
        ? html`<i>${ problems.message || 'Error' }</i>`
        : formatProblems(problems);
      table.querySelector('#tio-problems-row').style.display =
        Array.isArray(problems) && problems.length === 0 ? 'none' : '';
      if (Array.isArray(problems)) {
        table.querySelector('#tio-input').innerHTML = wiggles(srcText, problems);
      }

      table.querySelector('#tio-flat-tree').innerHTML =
        flatParseTree instanceof Error
        ? html`<i>${ flatParseTree.message || 'Error' }</i>`
        : html`${ JSON.stringify(flatParseTree, replaceTokenWithTokenText) }`;

      if (!(flatParseTree instanceof Error)) {
        try {
          ast = new Error('grammar application failed');
          let result = toyLanguageGrammar.apply(prodsel.value, flatParseTree);
          if (result && result.ast) {
            ast = result.ast;
          }
        } catch (ex) {
          ast = ex instanceof Error ? ex : new Error(ex);
          console.error(ex);
        }
      }

      table.querySelector('#tio-ast').innerHTML =
        ast instanceof Error
        ? html`<i>${ ast.message || 'Error' }</i>`
        : formatAst(ast && ast.length === 1
                    ? ast[0] : { type: 'forest', children: ast });

      let groupedPartsOfSpeech = new Error('Tagging failed');
      try {
        groupedPartsOfSpeech = groupPartsOfSpeech(tagPartsOfSpeech(tokens));
      } catch (ex) {
        groupedPartsOfSpeech = ex instanceof Error ? ex : new Error(ex);
      }

      table.querySelector('#tio-pos').innerHTML =
        groupedPartsOfSpeech instanceof Error
        ? html`<i>${ posTokens.message || 'Error' }</i>`
        : formatPartsOfSpeech(groupedPartsOfSpeech);
    } finally {
      console.groupEnd();
    }
  }

  function updateTryItOutForm() {
    setTimeout(() => tryItOut(document.getElementById('tio-inp').value), 0);
  }

  function populateTryItOut(input) {
    const prodsel = document.getElementById('production-select')
    const tioInp = document.getElementById('tio-inp');

    prodsel.value = /[;{]/.test(input) ? 'program' : 'expr';
    tioInp.value = input;
    tioInp.scrollIntoView();
    updateTryItOutForm();
    tioInp.focus();
    tioInp.select();
  }
</script>

<p>&uarr; Output, &darr; Input</p>
<form target="#" onsubmit="updateTryItOutForm(); return false">
  <select id="production-select"></select><br>
  <textarea style="font-family: sansserif" cols="80" rows="10" placeholder="C-like tokens"
            spellcheck="false" id="tio-inp"
            onfocus="this.select()">for (let i : number = 0, n = 10; i < n;) {
  (foo += i++ * 123);
}</textarea>
  <br>
  <button style="font-size: 150%" type="submit">Parse and display</button>
</form>

<script>
document.getElementById('production-select').innerHTML = html.join(
  [...toyLanguageGrammar.productionNames()].sort().map(
    (name) =>
      html`<option ${ name === 'program' ? 'selected' : '' }>${ name }</option>`
  ));
</script>

<script src="toc.js"></script>

<script>
  // Check that links to internally defined anchors are not broken.
  test(
    () => {
      let pass = true;
      console.group('Checking internal links');
      try {
        for (const a of document.querySelectorAll('a[href^="#"]')) {
          const url = a.getAttribute('href');
          if (!document.querySelector(url)) {
            console.error(
              'Broken link to %s with text `%s`: %o',
              url, a.textContent, a);
            pass = false;
          }
        }
      } finally {
        console.groupEnd();
      }
      return pass;
    }
  );
</script>

<script>
  // Check that visible scripts don't have overly long lines
  test(
    () => {
      console.group('Long line check');
      try {
        for (const script of document.querySelectorAll('script.visible')) {
          let longLine = /.{81,}/;
          let match = longLine.exec(script.textContent);
          if (match) {
            console.error(`Overly long line: ${ match[0] }`);
            return false;
          }
        }
      } finally {
        console.groupEnd();
      }
      return true;
    }
  );
</script>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/prettify.js"></script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/prettify.css">

<script>
  populateTableOfContents();
  updateTryItOutForm();
  runDeferredTests().finally(() => {
    setTimeout(
      () => {
        if (location.hash === '#' + FAILING_TEST_DOMID) {
          document.getElementById('teststatus').click();
        } else if (location.hash) {
          const el = document.getElementById(location.hash.substring(1));
          if (el) {
            el.scrollIntoView();
          }
        }
      },
      0);
  });
</script>


<script>
  // Pretty print visible scripts
  (() => {
    for (const script of document.querySelectorAll('script.visible')) {
      setTimeout(
        () => {
          let pre;
          if (script.classList.contains('hoisted') && script.id) {
            pre = document.querySelector(`pre#unhoist-${ script.id }`);
          }
          if (!pre) {
            pre = document.createElement('pre');
          }

          pre.className = `prettyprint lang-js ${ script.className }`;
          ([ pre.id, script.id ] = [ script.id, '' ]);
          const sourceText = script.textContent;
          pre.textContent = sourceText;
          if (!pre.parentNode) {
            script.parentNode.insertBefore(pre, script);
          }
          pre.innerHTML = prettyPrintOne(escHtml(sourceText), 'js');
          script.style.display = 'none';
        },
        0);
    }
  })();
  prettyPrint();
</script>

<div style="color:#888; text-align: center"><small>Thanks for reading!</small></div>
